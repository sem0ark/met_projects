<!-- 
    
    Copyright (C) Svetlin Tassev

// This file is part of CrochetPARADE.

// CrochetPARADE is free software: you can redistribute it and/or modify it under 
// the terms of the GNU General Public License as published by the Free Software 
// Foundation, either version 3 of the License, or (at your option) any later version.

// CrochetPARADE is distributed in the hope that it will be useful, but WITHOUT 
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

// You should have received a copy of the GNU General Public License along 
// with CrochetPARADE. If not, see <https://www.gnu.org/licenses/>.

 -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>CrochetPARADE</title>

    <script type="importmap">
        {
           "imports": {
             "three": "./three.module.js"
           }
         }
       </script>
    <script src="./prism.min.js"></script>

    <style>
        canvas {
            border: 1px solid black;
        }

        #contextMenu {
            position: absolute;
            background-color: #f9f9f9;
            border: 1px solid #ccc;
            padding: 5px;
            z-index: 2000;
            display: none;
        }

        #contextMenu button {
            display: block;
            width: 100%;
            padding: 5px;
            margin: 2px 0;
        }

        #generatorDialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            border: 1px solid black;
            padding: 20px;
            z-index: 1500;
            overflow: auto;
            box-sizing: border-box;
        }

        /* Custom Prism.js token styles */
        .language-html .comment {
            font-weight: 540;
            color: rgb(128, 128, 128);
        }

        .language-html .def {
            font-weight: 540;
            color: rgb(121, 42, 121);
        }

        .language-html .transform {
            font-weight: 540;
            color: rgb(111, 59, 174);
        }
        .language-html .dot1 {
            font-weight: 540;
            color: rgb(150, 50, 50);
        }

        .language-html .dot2 {
            font-weight: 540;
            color: rgb(150, 50, 50);
        }

        .language-html .dot {
            font-weight: 540;
            color: rgb(150, 50, 50);
        }

        .language-html .color {
            font-weight: 540;
            color: rgb(193, 124, 15);
        }

        .language-html .labelat {
            font-weight: 540;
            color: rgb(80, 200, 80);
            /* Color for labels starting with @ */
        }

        .language-html .labeldot {
            font-weight: 540;
            color: rgb(37, 170, 226);
            /* Color for labels starting with . */
        }

        .language-html .special {
            font-weight: 540;
            color: rgb(250, 0, 0);
        }

        .language-html .dollar {
            font-weight: 540;
            color: rgb(40, 160, 150);
        }

        .language-html .bracket {
            font-weight: 540;
            color: blue;
        }

        .language-html .number {
            font-weight: 540;
            color: rgb(153, 0, 79);
        }

        .language-html .punctuation {
            font-weight: 540;
            color: rgb(85, 85, 85);
        }

        .language-html .unknown {
            font-weight: 540;
            background-color: #ff2121;
        }

        .language-html .string {
            font-weight: 540;
            color: brown;
        }

        .language-html .brokenbracket1 {
            font-weight: 540;
            background-color: rgb(200, 100, 100);
        }

        .language-html .brokenbracket {
            font-weight: 540;
            background-color: rgb(200, 100, 100);
        }

        .language-html .words {
            font-weight: 540;
            background-color: rgba(0, 0, 0, 0);
        }

        #translateZSlider {
            accent-color: red;
        }

        #rotateGammaSlider {
            accent-color: #0075ff;
        }

        #closeButton {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            cursor: pointer;
        }

        .control-group {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-direction: column;
        }

        .control-section {
            flex: 1;

        }

        .control-label {
            font-weight: bold;
        }

        .canvas-container {
            display: flex;
            align-items: center;
        }

        canvas {
            background-color: #e0e0e0;
        }

        input[type="range"] {

            writing-mode: vertical-lr;
            direction: rtl;
            width: 20px;
            height: 201px;
            margin-left: 10px;
        }

        .input-group {
            justify-content: space-between;
            margin-top: 10px;
        }

        .input-group input[type="number"] {
            width: 60px;
        }

        .button-group {
            display: flex;

            margin-top: 10px;
        }

        button {
            padding: 3px 4px;
        }

        @media (max-width: 1200px) {
            .control-group {
                flex-direction: column;
            }
        }

        #dragHandle {
            height: 2ch;
            cursor: move;
            /* Add any other styling you want for the top bar */
        }

        #controlPanel {
            /* Modified for floating and dragging */
            display: none;
            position: absolute;
            /* Changed from fixed to absolute */
            top: 20px;
            left: 20px;
            min-width: 300px;
            /* Ensure it's wide enough */
            max-width: 600px;
            /* but not too wide */
            height: auto;
            max-height: 100%;
            /* Limit height so it doesn't take over the screen */
            background-color: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            z-index: 3000;
            border: 1px solid #ccc;

            /* Indicate it's draggable */
        }

        #closeButton {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            cursor: pointer;
        }

        #examples {
            appearance: none;
            /* Hide the default arrow in some browsers */
            -webkit-appearance: none;
            /* Hide the default arrow in WebKit browsers */
            -moz-appearance: none;
            /* Hide the default arrow in Firefox */

            /* Add some padding to the right to make space for the arrow */
        }


        .radio-buttons label {
            font-size: 14pt;
        }



        .button-bar {
            display: flex;
            justify-content: left;
            /*background-color: rgb(240, 240, 245);*/
            /* Background color */
            padding: 0px;
            margin: 0;
            border: 0;
            align-self: stretch;

        }


        .button,
        .button1,
        .button2,
        .label {
            flex: 1;
            align-self: stretch;
        }



        .button {
            outline: none;
            /* Remove the outline */

            font-size: 14pt;
            background-color: #a2d1f0;
            border: none;
            color: rgb(0, 0, 0);
            padding: 5px 5px;
            /* Smaller padding */
            text-align: left;
            text-decoration: none;
            display: inline-block;
            /* Smaller font size */
            border-radius: 2px;
            cursor: pointer;
            margin: 2px;
            /* Remove default margin */
        }

        #examples,
        .label {
            outline: none;
            /* Remove the outline */

            font-size: 14pt;
            background-color: #a2d1f0;
            border: none;
            color: rgb(0, 0, 0);
            padding: 5px 10px;
            /* Smaller padding */
            text-align: left;
            text-decoration: none;
            display: inline-block;
            /* Smaller font size */
            border-radius: 2px;
            cursor: pointer;
            margin: 2px;
            /* Remove default margin */
        }

        .button1 {
            outline: none;
            /* Remove the outline */

            font-size: 14pt;
            background-color: #fbce1a;
            border: none;

            color: rgb(0, 0, 0);
            padding: 5px 10px;
            /* Smaller padding */
            text-align: left;
            text-decoration: none;
            display: inline-block;
            /* Smaller font size */
            border-radius: 2px;
            cursor: pointer;
            margin: 2px;
            box-shadow: 5px 2px 4px rgba(0, 0, 0, 0.3);
            background: linear-gradient(to right, #fbce1a, #d89000);
            /* d86f00Remove default margin */
        }

        .button2 {
            outline: none;
            /* Remove the outline */

            font-size: 14pt;

            border: none;

            color: rgb(0, 0, 0);
            padding: 5px 10px;
            /* Smaller padding */
            text-align: left;
            text-decoration: none;
            display: inline-block;
            /* Smaller font size */
            border-radius: 2px;
            cursor: pointer;
            margin: 2px;
            box-shadow: 5px 2px 4px rgba(0, 0, 0, 0.3);
            background: linear-gradient(to right, #c31bc9, #e75fff);
            /* d86f00Remove default margin */
        }

        .spacer {
            margin-right: 3px;
        }

        #examples {
            padding-right: 20pt
        }

        /*From csstricks: https://css-tricks.com/creating-an-editable-textarea-that-supports-syntax-highlighted-code/ */

        #inputText,
        #highlighting {
            /* Both elements need the same text and space styling so they are directly on top of each other */

            padding: 0;
            border: 0;
            margin: 0;
            overflow-x: visible;
            overflow-y: hidden;

            width: 9999px;
        }

        #inputText,
        #highlighting {
            /* Also add text styles to highlighing tokens */
            left: 0;
            line-height: 21pt;
            tab-size: 2;
        }

        #inputText,
        #highlighting {
            /* In the same place */
            position: absolute;
            top: 0;
            left: 0;
        }


        /* Move the textarea in front of the result */

        #inputText {
  z-index: 1; /* Above highlighting */
  pointer-events: auto; /* Allow typing */

        }

        #highlighting {
            z-index: 0; /* Bring highlighting above textarea */
            pointer-events: none; /* Allow interaction with spans for tooltips */
        }


        /* Make textarea almost completely transparent */
        #highlighting .token.words {
  pointer-events: auto;
}
#custom-tooltip {
  position: fixed;
  background: #333;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: monospace;
  pointer-events: none; /* Avoid blocking hover */
  display:none;
  z-index:5000;
}
        #inputText {
            color: transparent;
            background: transparent;
            caret-color: black;
            /* Or choose your favourite color */
        }

        /* Paragraphs; First Image */


        p code {
            border-radius: 2px;
            background: transparent;
            color: rgb(34, 34, 34);
        }

        /**/


        .info-box {
            display: none;
            position: absolute;
            top: 0%;
            margin-top: 0;
            left: 50%;
            transform: translate(-50%, 0%);

            font-size: 14pt;
            overflow-y: auto;


            padding: 20px;
            background-color: #f2f2f2;
            border: 1px solid #ccc;
            z-index: 1000;
        }

        #dialog-box {
            display: none;
            position: fixed;
            font-size: 14pt;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }

        #dialog-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }

        .close-btn {
            color: #aaa;
            float: right;
            font-size: 26px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-btn:hover {
            color: #000;
        }


        .editor_container,
        #view3d {
            box-sizing: border-box;
        }


        /* Styling for side-by-side view */
        .side-by-side {
            float: left;
            width: 50%;
            height: 80vh;
            /* 100% of the viewport height */
        }

        /* Styling for stacked view */
        .stacked {
            width: 100vw;
            height: 100vh;
        }

        .editor_container {
            border-radius: 0px;
            padding: 0px 0px;
            margin: 0;
            border: 0;
            max-height: 100vh;

            line-height: 21pt;
            max-width: 100%;
            overflow-y: scroll;
            overflow-x: hidden;
        }

        .hor_scroll {
            border-radius: 0px;
            padding: 0px 0px;
            margin: 0px;
            border: 0px;
            width: 100%;
            overflow-y: clip;
            overflow-x: auto;
        }

        .editor {
            display: inline-flex;
            gap: 10px;
            font-family: monospace;
            font-size: 14pt;
            line-height: 21pt;
            background: rgb(240, 240, 240);
            border-radius: 2px;
            max-height: 9999px;
            width: 100%;
            padding: 0px 10px;
            border: 0px;
            overflow-x: visible;
            overflow-y: visible;
        }

        .numbers {
            width: 25px;
            text-align: right;
            height: 100%;
            padding: 0px;
            margin: 0;
            border: 0px;

            color: rgb(130, 130, 130);
            line-height: 21pt;
        }



        textarea {

            font-family: monospace;
            font-size: 14pt;
            line-height: 21pt;
            outline: none;
            resize: none;

        }

        .dropbtn {
            background-color: #a2d1f0;
            color: black;
            padding: 5px;
            font-size: 14pt;
            border: none;
            cursor: pointer;
        }

        .dropbtn:hover,
        .dropbtn:focus,
        #examples:hover,
        .button:hover,
        .label:hover {
            background-color: #89bfe3;
        }

        .dropdown {
            position: relative;
            display: inline-block;
            z-index: 1000;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
            z-index: 4000;
        }

        .dropdown-content a {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }

        .dropdown-content a:hover {
            background-color: #ddd;
        }

        .show {
            display: block;
        }


        .button-examples {
            margin: 2px;
            background-color: #f9f9f9;
        }


        .dropdown-content button {
            width: 100%;
            /* Make the buttons fill the width of the menu */
            text-align: left;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            background-color: transparent;
            /* Set the background color to transparent */
            border: none;
            /* Remove the border */
            cursor: pointer;
        }

        .dropdown-content label {
            font-family: sans-serif;
            width: 100%;
            /* Make the buttons fill the width of the menu */
            text-align: left;
            padding: 12px 0px;
            margin: 0;
            font-size: 14pt;
            line-height: 21pt;
            text-decoration: none;
            display: block;
            background-color: transparent;
            /* Set the background color to transparent */
            border: none;
            /* Remove the border */
            cursor: pointer;
        }

        .dropdown-content button:hover,
        .dropdown-content label:hover,
        .button-examples:hover {
            background-color: #dcdcdc;
            /* Add a background color on button hover */
        }

        .container {
            display: flex;
            align-items: center;
            font-size: 26px;
            font-weight: 600;
            color: rgb(35, 35, 36);
        }

        .logo {
            flex: 0 0 auto;
            margin-right: 10px;
            max-width: 100pt;
        }

        .title-author {
            display: flex;
            flex-direction: column;
        }

        .control-canvas {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }

        .title {
            font-size: 26px;
            font-weight: 600;
            margin: 0;
        }

        .author {
            font-size: 18px;
            font-weight: 400;
            margin: 3px 0 0 0;
        }

        .date {
            font-size: 14px;
            font-weight: 400;
            margin: 2px 0 0 0;
        }

        #display {
            position: fixed;
            top: 11pt;
            right: 133pt;
            background-color: rgba(246, 201, 21, 0.8);
            /*rgba(255, 234, 95, 0.77); */
            pointer-events: none;
            color: rgb(255, 106, 0);
            -webkit-text-stroke: 1px rgb(100, 100, 100);
            font-size: 24pt;
            font-weight: 600;
            z-index: 1000;
            padding: 5px;
            margin: 5px;
        }



        #mouse {
            position: fixed;
            top: 10pt;
            right: 10pt;
            background-color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            color: rgb(215, 215, 215);
            -webkit-text-stroke: 1px rgb(100, 100, 100);
            font-size: 15pt;
            font-weight: 600;
            z-index: 1000;
            border: 1px solid rgb(100, 100, 100);
            border-radius: 5px;
            padding: 5px;
            height: 36pt;
            line-height: 24pt;

            display: flex;
            justify-content: center;
            align-items: center;

        }

        .buttonM {
            display: inline-block;
            pointer-events: none;
            background-color: rgb(235, 235, 235);
            border: 1px solid rgb(100, 100, 100);
            border-radius: 5px;
            padding: 2px;
            margin: 0px;
            width: 30pt;
            height: 30pt;
            line-height: 30pt;
            margin: 2px
        }

        #up,
        #down {
            display: block;
            text-align: center;
            height: 15pt;
            line-height: 15pt;
            margin-bottom: -1pt;
        }

        .highlight-font {

            color: rgb(255, 106, 0);
        }

        .highlight-font-arrows {

            color: rgba(246, 201, 21, 0.8);
        }

        .highlight {

            background-color: rgba(246, 201, 21, 0.8);
        }

        input[type="range"] {
            margin-bottom: 5px;
        }

        /* New Styles */
        #objectInput {
            width: 6ch;
            margin-bottom: 10px;
            /* Add spacing below the input */
        }

        .button-group-bottom {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        /* Ensure buttons are on separate lines */
        .button-group-bottom button {
            width: 100%;
            margin-bottom: 5px;
            /* Add spacing between buttons */
        }

        /* Flexbox for control sections */
        .control-sections-container {
            display: flex;
            gap: 20px;
        }

        /* Stack on smaller screens */
        @media (max-width: 768px) {
            .control-sections-container {
                flex-direction: column;
                /* Stack the sections */
            }
        }
    </style>
    <link rel="icon" type="image/png" href="icon.png">


</head>

<body>





    <div id="generatorDialog">

        <div style="display: flex; align-items: center; gap: 10px;">
            <img class="logo" src="./logo.png" alt="CrochetPARADE" style=""">
            <button id="okayButton" style="font-size: 1.2em; padding: 10px 20px; background-color: #fbce1a;">Generate</button>
            <button id="resetShapeButton" onclick="resetPoints()" style="font-size: 1.2em; padding: 10px 20px;">Reset</button>

            <button id="exportButton" style="font-size: 1.2em; padding: 10px 20px; background-color: #4CAF50;">Export</button>
            <button id="importButton" style="font-size: 1.2em; padding: 10px 20px; background-color: #2196F3;">Import</button>
            <button id="clButton"" style=" top: 10px; right: 10px; font-size: 1.2em; background-color: #f44336; color: white; border: none; padding: 5px 10px; cursor: pointer;">×</button>

        </div>
        <br>
        <div style="width: 700px;padding: 25px; background-color: #f0f0f0; border-radius: 8px; ">
            <div style="margin-bottom: 15px;font-weight:700">Hint: Try holding either Ctrl or Shift when dragging the point handles.</div>
            <div style="margin-bottom: 15px;">
                <label for="scatterShape" style=" margin-bottom: 5px;">Scatter increases and decreases (may reduce distortions):</label>
                <input type="checkbox" id="scatterShape" checked style="margin-right: 5px;">
            </div>

            <div style="margin-bottom: 15px;">
                <label for="numStitches" style=" margin-bottom: 5px;">Number of stitches between green grid lines:</label>
                <input type="number" id="numStitches" value="20" min="1" style="width: 10ch; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
            </div>

            <div style="margin-bottom: 15px;">
                <label for="xAxisRangeDialog" style=" margin-bottom: 5px;">X-axis range:</label>
                <input type="number" id="xAxisRangeDialog" value="1.4" min="0.1" step="0.1" style="width: 10ch; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
            </div>

            <div style="margin-bottom: 15px;">
                <label for="yAxisLengthDialog" style=" margin-bottom: 5px;">Y-axis range:</label>
                <input type="number" id="yAxisLengthDialog" value="1.4" min="0.1" step="0.1" style="width: 10ch; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
            </div>

            <div style="margin-bottom: 15px;">
                <label for="thicknessB" style="margin-bottom: 5px;">Show curve to adjust number of stitches in the round:</label>
                <input type="checkbox" id="thicknessB" style="margin-right: 5px;">
            </div>
        </div>
        <div id="thicknessContainer" style="display: none; ">
            <button id="resetThicknessBtn" style="background-color:rgb(255, 140, 255);right: 0; z-index: 3;">Reset number of stitches in the round</button>
            <div style="position: relative;">
                <canvas id="thicknessCanvas"></canvas>

            </div>
        </div>


        <canvas id="generatorCanvas"></canvas>

    </div>

    <div id="contextMenu">
        <button id="addPoint">Add Point</button>
        <button id="deletePoint">Delete Point</button>
    </div>
    <div id="controlPanel">
        <div id="dragHandle"></div>

        <span id="closeButton">&times;</span>
        <div class="control-group">
            <div class="control-label">Object: <input type="number" id="objectInput" min="0" max="100" value="0" step="1"></div>
            <div class="control-label">Guiding plane: <input type="checkbox" id="toggleGuidesCheckbox" unchecked> Guiding rotation axes: <input type="checkbox" id="toggleGuideAxesCheckbox" unchecked>
                Rotation order:
                <select id="rotationOrderSelect">
                    <option value="XYZ" selected>XYZ</option>
                    <option value="YZX">YZX</option>
                    <option value="ZXY">ZXY</option>
                    <option value="XZY">XZY</option>
                    <option value="YXZ">YXZ</option>
                    <option value="ZYX">ZYX</option>
                </select>
            </div>
            <div class="control-canvas">
                <div class="control-section">
                    <div class="control-label">Translation</div>
                    <div class="canvas-container">
                        <canvas id="translateCanvas" width="201" height="201"></canvas>
                        <input type="range" id="translateZSlider" min="-10" max="10" value="0" step="0.001">
                    </div>
                    <div class="input-group">
                        <input type="number" id="translateXInput" value="0" step="0.001">
                        <input type="number" id="translateYInput" value="0" step="0.001">
                        <input type="number" id="translateZInput" value="0" step="0.001">
                    </div>
                    <div class="button-group">
                        <button id="resetTranslation">Reset Translation</button>
                        <button id="resetTranslationMinMax">Reset Min/Max</button>
                    </div>
                </div>
                <div class="control-section">
                    <div class="control-label">Rotation</div>
                    <div class="canvas-container">
                        <canvas id="rotateCanvas" width="201" height="201"></canvas>
                        <input type="range" id="rotateGammaSlider" min="-180" max="180" value="0" step="0.1">
                    </div>
                    <div class="input-group">
                        <input type="number" id="rotateAlphaInput" value="0" step="0.1">
                        <input type="number" id="rotateBetaInput" value="0" step="0.1">
                        <input type="number" id="rotateGammaInput" value="0" step="0.1">
                    </div>
                    <div class="button-group">
                        <button id="resetRotation">Reset Rotation</button>
                    </div>
                </div>


            </div>
            <div class="control-group">
                <button onclick="readInstructions()">Read from instructions</button>
                <button onclick="updateTextArea();update(textarea.value);onMyInput();">Write to instructions</button>


            </div>
        </div>
    </div>
    <div class="container">
        <img class="logo" src="./logo.png" alt="CrochetPARADE">
        <div class="title-author">
            <p class="title">CrochetPARADE: Crochet PAttern Renderer, Analyzer and DEbugger</p>
            <p class="author">Svetlin Tassev</p>
            <p class="date">Updated: June 20, 2025. Allow for more localized repulsion between stitches when inflating the model. See <a href="https://crochetparade.org/crochetforum/showthread.php?tid=39&pid=71#pid71"  target="_blank">amigurumi legs demo</a>.
        </div>
        </p>
    </div>
    </div>
    <div id="announcement" style="background-color:rgb(253, 79, 79);color:#ffffff; font-size: 14pt; position: relative;">
        <span style="cursor: pointer; position: absolute; top: 5px; right: 5px;font-size:20pt;font-weight:600" onclick='closeAnnouncement("announcement")'>×</span>
        <b>The platform has been tested with the latest Chrome, Brave and Firefox browsers. Some Safari versions have issues loading it correctly. <br>
            The platform is not designed for mobile devices and works best on a computer.</b>
    </div>
    <!--    
    <div style="height:2pt"></div>
    <div id="announcement4" style="background-color:rgb(185, 75, 114);color:#ffffff; font-size: 14pt; position: relative;">
        <span style="cursor: pointer; position: absolute; top: 2px; right: 5px;font-size:20pt;font-weight:600" onclick='closeAnnouncement("announcement4")'>×</span>
        <b>I made a breaking change to the CP language. The special command TRANSFORM_OBJECT: should not be preceeded by a # anymore. So, delete the pound sign to make your pattern work.
        </b>
    </div>

    <div style="height:2pt"></div>
    <div id="announcement2" style="background-color:rgb(253, 79, 79);color:#382e2e; font-size: 14pt; position: relative;">
        <span style="cursor: pointer; position: absolute; top: 5px; right: 5px;font-size:20pt;font-weight:600" onclick='closeAnnouncement("announcement2")'>×</span>
        <b>UPDATE2: Added new stitches to standard crochet diagram export: bobbles, puffs, popcorns; fixed back post and front post stitch placement. See Swatch 1 demo as an example.
        </b><br>
        <b>UPDATE1: CrochetPARADE can now export crochet charts with standard crochet symbols. <br>Export to SVG and one of the 3 output SVG files will contain the standard crochet chart (you need to allow multiple downloads if asked). Note that this feature is work in progress. Check out the video introducing the feature:
            <br> <iframe width="200" height="150" src="https://www.youtube.com/embed/obUhiLLJnDg" title="UPDATE: Exporting standard crochet patterns using CrochetPARADE" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture;" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        </b>
    </div>
     -->
    <!-- <div style="height:2pt"></div>
    <div id="announcement2" style="background-color:rgb(253, 79, 79);color:#ffffff; font-size: 14pt; position: relative;height:20pt">
        <span style="cursor: pointer; position: absolute; top: -1px; right: 5px;font-size:20pt;font-weight:600" onclick='closeAnnouncement("announcement2")'>×</span>
        <b>CrochetPARADE was updated to support crocheting in the back and front loops. See the Mosaic crochet showcase as well as the manual.</b>
    </div> -->
    <script>
            var tempElement = document.createElement("pre");
        
        var shape;
    </script>
    <script src="bezier58.js"></script>
    <script>
        window.onload = function() {
            document.getElementById('thicknessB').checked = false;
        };
        var c_was_pressed = false;
        var factor_radius = 1.0;
        var requestedInfo = true;

        function closeAnnouncement(a) {
            var announcement = document.getElementById(a);
            announcement.style.display = "none";
        }
        document.addEventListener('DOMContentLoaded', function() {
            const controlPanel = document.getElementById('controlPanel');
            const dragHandle = document.getElementById('dragHandle');
            let isDragging = false;
            let isResizing = false;
            let offsetX, offsetY, startWidth, startHeight;

            dragHandle.addEventListener('mousedown', function(e) {
                isDragging = true;
                offsetX = e.clientX - controlPanel.offsetLeft;
                offsetY = e.clientY - controlPanel.offsetTop;
                dragHandle.style.cursor = 'grabbing';
            });

            document.addEventListener('mouseup', function() {
                isDragging = false;
                isResizing = false;
                dragHandle.style.cursor = 'grab';
                document.body.style.cursor = 'default';
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    controlPanel.style.left = (e.clientX - offsetX) + 'px';
                    controlPanel.style.top = (e.clientY - offsetY) + 'px';
                } else if (isResizing) {
                    const width = startWidth + (e.clientX - offsetX);
                    const height = startHeight + (e.clientY - offsetY);
                    controlPanel.style.width = Math.max(200, width) + 'px';
                    controlPanel.style.height = Math.max(100, height) + 'px';
                }
            });

            dragHandle.addEventListener('mouseover', function() {
                if (!isDragging) {
                    this.style.cursor = 'grab';
                }
            });

            dragHandle.addEventListener('mouseout', function() {
                if (!isDragging) {
                    this.style.cursor = 'default';
                }
            });

            // New code for resizing
            controlPanel.addEventListener('mousedown', function(e) {
                const rect = controlPanel.getBoundingClientRect();
                const isOnRightEdge = e.clientX > rect.right - 20;
                const isOnBottomEdge = e.clientY > rect.bottom - 20;

                if (isOnRightEdge || isOnBottomEdge) {
                    isResizing = true;
                    offsetX = e.clientX;
                    offsetY = e.clientY;
                    startWidth = parseInt(document.defaultView.getComputedStyle(controlPanel).width, 10);
                    startHeight = parseInt(document.defaultView.getComputedStyle(controlPanel).height, 10);
                    document.body.style.cursor = isOnRightEdge && isOnBottomEdge ? 'se-resize' :
                        isOnRightEdge ? 'e-resize' : 's-resize';
                }
            });

            controlPanel.addEventListener('mousemove', function(e) {
                if (!isResizing) {
                    const rect = controlPanel.getBoundingClientRect();
                    const isOnRightEdge = e.clientX > rect.right - 20;
                    const isOnBottomEdge = e.clientY > rect.bottom - 20;

                    this.style.cursor = isOnRightEdge && isOnBottomEdge ? 'se-resize' :
                        isOnRightEdge ? 'e-resize' :
                        isOnBottomEdge ? 's-resize' : 'default';
                }
            });
        });
    </script>



    <script src="./parse58.js"></script>
    <script src="./svg.min.js"></script>
    <!--<script src="./math.js"></script>-->


    <script src="simplify58.js"></script>
    <div id="mouse">
        <span id="left" class="buttonM"></span>
        <span id="middle" class="buttonM">
            <span id="up">&#9650;</span>
            <span id="down">&#9660;</span>
        </span>
        <span id="right" class="buttonM"></span>
    </div>
    <div id="display"></div>

    <script>
        var showinfo = false;
        document.getElementById('mouse').style.display = 'none';
        document.getElementById('display').style.display = 'none';
        document.addEventListener('keydown', function(event) {
            if ((event.altKey) && ((event.ctrlKey|| event.metaKey)) && (event.key === '1'))
                showinfo = !showinfo;
            if (showinfo) {
                document.getElementById('mouse').style.display = 'flex';
                document.getElementById('display').style.display = 'block';
            } else {
                document.getElementById('mouse').style.display = 'none';
                document.getElementById('display').style.display = 'none';
            }
        })
        var renderer = null;
        var updateTextArea = null;
        var readInstructions = null;
        var canvasClicked = false
        document.addEventListener('mousedown', function(event) {
            if ((renderer === null) || event.target !== renderer.domElement) {
                canvasClicked = false;
            } else
                canvasClicked = true;
        });


        var timeoutID = null;
        var timeoutID1 = null;
        // Map of special keys
        const specialKeys = {
            "Control": "Ctrl",
            "Alt": "Alt",
            "Shift": "Shift",
            "Tab": "Tab",
            "Escape": "Esc"
        };
        document.addEventListener("wheel", function(event) {

            var message = event.deltaY > 0 ? "~down" : "~up";

            display(message);
        });

        document.addEventListener("auxdown", function(event) {
            if (event.button === 1) { // 1 is the code for the middle mouse button

                display("~middle");
            }
        });
        document.addEventListener("auxup", function(event) {
            if (event.button === 1) { // 1 is the code for the middle mouse button

                display("!middle");
            }
        });

        function display(text) {
            if (timeoutID != null)
                clearTimeout(timeoutID);
            if (timeoutID1 != null)
                clearTimeout(timeoutID1);

            var myLabel = document.getElementById("display");
            if (canvasClicked) {
                if (text[0] === '~' && text.length > 1) {
                    if (!(['up', 'down'].includes(text.slice(1))))
                        document.getElementById(text.slice(1)).classList.add("highlight");
                    else
                        document.getElementById(text.slice(1)).classList.add("highlight-font");
                } else if (text[0] === '!' && text.length > 1) {
                    if (['right', 'left', 'middle'].includes(text.slice(1))) document.getElementById(text.slice(1)).classList.remove("highlight");
                } else
                    myLabel.innerText = text;
            } else if (text.length > 1 && (!(['~', '!'].includes(text[0])))) {
                myLabel.innerText = text;
            }


            timeoutID1 = setTimeout(() => {

                //myLabel.style.display = 'none';
                try {

                    document.getElementById('down').classList.remove("highlight-font");
                    document.getElementById('up').classList.remove("highlight-font");
                } catch (error) {}
            }, 100);

            timeoutID = setTimeout(() => {

                //myLabel.style.display = 'none';
                try {
                    for (let i in Object.keys(pressedSpecialKeys))
                        delete pressedSpecialKeys[i]
                    myLabel.innerText = ""
                } catch (error) {}
            }, 500);
        }

        // Variable to store the pressed special keys
        let pressedSpecialKeys = {};

        // Function to update the display
        function updateDisplay() {
            const pressed = Object.values(pressedSpecialKeys).join("+");
            document.getElementById("display").innerText = (pressed);
        }

        // Capture and display key press including special keys
        document.addEventListener("keydown", function(event) {

            if (event.key in specialKeys) {
                pressedSpecialKeys[event.key] = specialKeys[event.key];
                updateDisplay();
            } else {
                var keyCombination
                if (!event.ctrlKey)
                    delete pressedSpecialKeys['Control']
                else
                    pressedSpecialKeys['Control'] = specialKeys['Control'];
                if (!event.altKey)
                    delete pressedSpecialKeys['Alt'];
                else
                    pressedSpecialKeys['Alt'] = specialKeys['Alt'];
                if (!event.shiftKey)
                    delete pressedSpecialKeys['Shift'];
                else
                    pressedSpecialKeys['Shift'] = specialKeys['Shift'];

                if (Object.values(pressedSpecialKeys).join("+").length > 0)
                    keyCombination = Object.values(pressedSpecialKeys).join("+") + "+" + event.key.toUpperCase();
                else
                    keyCombination = event.key.toUpperCase();
                display(keyCombination);
            }
        });

        // Remove special key from the list when released
        document.addEventListener("keyup", function(event) {
            if (event.key in specialKeys) {

                delete pressedSpecialKeys[event.key];
                updateDisplay();
            }
        });

        document.addEventListener("mouseup", function(event) {
            var buttonClicked = event.button;
            var buttonName = buttonClicked === 0 ? "left" : (buttonClicked === 1 ? "middle" : "right");
            // console.log('!' + buttonName)
            display("!" + buttonName);
        });

        document.addEventListener("mousedown", function(event) {

            var buttonClicked = event.button;
            var buttonName = buttonClicked === 0 ? "left" : (buttonClicked === 1 ? "middle" : "right");
            display("~" + buttonName);
        });
        document.addEventListener("contextmenu", function(event) {

            display("~right");
        });

        function expandExpression(substitute = true) {
            // Create a dialog box
            var dialog = document.createElement('div');
            dialog.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:20px;border:1px solid black;z-index:1000;';

            // Warning message
            var warning = document.createElement('p');
            warning.style.cssText = 'font-weight:700;'
            warning.textContent = "Warning!!!";

            dialog.appendChild(warning);

            var warning1 = document.createElement('p');
            warning1.style.cssText = ''
            warning1.textContent = "This will overwrite your instructions with their expanded form. Expressions such as 3*[sc,dc] will be written out in expanded form (as in [sc,dc],[sc,dc],[sc,dc]); and newly defined stitches will be substituted when possible. If you want expressions such as 4sc to be expanded, then run this dialog twice in a row (or check the box below). After the first time, they will be written as 4*sc, and after the second time, they will be expanded as sc,sc,sc,sc.";

            dialog.appendChild(warning1);

            var warning2 = document.createElement('p');
            warning2.style.cssText = 'font-weight:700;'
            warning2.textContent = "Save your work before continuing!";

            dialog.appendChild(warning2);

            // Checkbox for "Expand before simplification?"
            var expandExprCheckboxContainer = document.createElement('div');
            expandExprCheckboxContainer.style.marginTop = '10px';

            var expandExprCheckboxLabel = document.createElement('label');
            expandExprCheckboxLabel.textContent = "Substitute index counters after expansion? If checked, index variables will be evaluated, so for example $k=0$,sc.L[k++],sc.L[k] will be written out as sc.L[0],sc.L[1].";
            expandExprCheckboxLabel.style.marginRight = '10px';

            var expandExprCheckbox = document.createElement('input');
            expandExprCheckbox.type = 'checkbox';
            expandExprCheckbox.style.marginTop = '4px';
            expandExprCheckbox.checked = false; // Default unchecked

            // Variable to store the checkbox state
            var expandExpr = false;

            // Update expandExpr based on checkbox state
            expandExprCheckbox.onchange = function() {
                expandExpr = expandExprCheckbox.checked;
            };

            expandExprCheckboxContainer.appendChild(expandExprCheckboxLabel);
            expandExprCheckboxContainer.appendChild(expandExprCheckbox);
            dialog.appendChild(expandExprCheckboxContainer);



            // Checkbox for "Expand before simplification?"
            var expandExprCheckboxContainer1 = document.createElement('div');
            expandExprCheckboxContainer1.style.marginTop = '10px';

            var expandExprCheckboxLabel1 = document.createElement('label');
            expandExprCheckboxLabel1.textContent = "Run this dialog twice in a row? If set, stitches will be indexed in the editor, and stitch numbers will appear on hover in editor.";
            expandExprCheckboxLabel1.style.marginRight = '10px';

            var expandExprCheckbox1 = document.createElement('input');
            expandExprCheckbox1.type = 'checkbox';
            expandExprCheckbox1.style.marginTop = '4px';
            expandExprCheckbox1.checked = false; // Default unchecked

            // Variable to store the checkbox state
            var twice = false;

            // Update expandExpr based on checkbox state
            expandExprCheckbox1.onchange = function() {
                twice = expandExprCheckbox1.checked;
            };

            expandExprCheckboxContainer1.appendChild(expandExprCheckboxLabel1);
            expandExprCheckboxContainer1.appendChild(expandExprCheckbox1);
            dialog.appendChild(expandExprCheckboxContainer1);


            // Questions and answers
            var questionsAndAnswers = [
                ["1 + 1 = ?", 2],
                ["2 + 2 = ?", 4],
                ["3 + 3 = ?", 6],
                ["4 + 4 = ?", 8],
                ["8 + 1 = ?", 9],
                ["3 + 6 = ?", 9],
                ["6 + 2 = ?", 8],
                ["1 + 1 = ?", 2],
                ["2 + 1 = ?", 3],
                ["3 + 2 = ?", 5],
                ["4 - 2 = ?", 2],
                ["5 - 3 = ?", 2],
                ["2 + 3 = ?", 5],
                ["6 - 4 = ?", 2],
                ["3 + 4 = ?", 7],
                ["7 - 5 = ?", 2],
                ["4 + 3 = ?", 7],
            ];
            var index = Math.floor(Math.random() * questionsAndAnswers.length);
            var [question, correctAnswer] = questionsAndAnswers[index];

            var questionElem = document.createElement('p');
            questionElem.textContent = "If you want to continue, please answer this question by entering a number:";
            dialog.appendChild(questionElem);

            var questionElem1 = document.createElement('p');
            questionElem1.textContent = question;
            dialog.appendChild(questionElem1);
            var input = document.createElement('input');
            input.type = 'number';
            dialog.appendChild(input);

            var buttonContainer = document.createElement('div');
            buttonContainer.style.marginTop = '10px';

            var okButton = document.createElement('button');
            okButton.textContent = 'OK';
            okButton.disabled = true; // Initially disabled
            okButton.onclick = function() {
                document.body.removeChild(dialog);
                proceedWithExpansion();
            };
            buttonContainer.appendChild(okButton);

            var cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.onclick = function() {
                document.body.removeChild(dialog);
            };
            buttonContainer.appendChild(cancelButton);

            dialog.appendChild(buttonContainer);

            // Enable OK button only when the correct answer is provided
            input.oninput = function() {
                okButton.disabled = (parseInt(input.value) !== correctAnswer);
            };

            document.body.appendChild(dialog);

            function proceedWithExpansion() {
                var inputText = document.getElementById("inputText");
                inputText.value = cleanString(evaluate_indices_and_stop(inputText.value, expandExpr));
                if (twice){
                    inputText.value = cleanString(evaluate_indices_and_stop(inputText.value, expandExpr));
                    inputText['expanded']=true;
                } else {inputText['expanded']=false;}
               
                update(inputText.value); onMyInput();
            }
        }
    function lathe() {   
        inputText.value=parseCrochetLathe(inputText.value);
        update(inputText.value); onMyInput();
    }
        
    function parseCrochetLathe(inputText) {
    const lines = inputText.trim().split('\n');
    let output = [];
    let mode = 'normal'; // can be 'normal', 'back', or 'front'
    let prevRowTokens = [];
    let inMagicCircle=false;
    for (let line of lines) {
        line = line.trim();
        if (!line) continue;

        // Detect magic circle/ring start
        if (/start with a magic (circle|ring)/i.test(line)) {
            output.push('ring.R');
            inMagicCircle = true;  // flag to handle first row differently
            continue;
        }

        // Detect loop start (non-magic circle)
        if (line.toLowerCase().startsWith("start with:")) {
            const m = line.match(/(\d+)\s*st/);
            if (m) {
                output.push(`${m[1]}ch`);
            }
            continue;
        }
        // Detect back/front loop mode switches
        if (line.includes("BACK loops only")) {
            mode = 'back';
            continue;
        }
        if (line.includes("FRONT loops only")) {
            mode = 'front';
            continue;
        }
        // Parse row instructions
        let m = line.match(/^Row\s+\d+\s*\[.*?\]:\s*(.*)/);
        if (m) {
            let instr = m[1].replace(/in the magic circle/g,'').replace(/ /g, ''); // Remove spaces
            let tokens = instr.split(',');
            let paradeTokens = [];
            prevRowTokens = tokens;
            for (let token of tokens) {
                // Match a plain number (e.g. 5)
                if (/^\d+$/.test(token)) {
                    if (mode === 'normal') paradeTokens.push(`${token}sc`);
                    else if (mode === 'back') paradeTokens.push(`${token}scbl`);
                    else if (mode === 'front') paradeTokens.push(`${token}scfl`);
                }
                // Match inc or dec with optional number (e.g. inc, inc4, dec, dec3)
                else if (/^inc(\d*)$/i.test(token)) {
                    let n = token.match(/^inc(\d*)$/i)[1];
                    let count = n ? parseInt(n) + 1 : 2;
                    let prefix = mode === 'normal' ? 'sc' : (mode === 'back' ? 'scbl' : 'scfl');
                    paradeTokens.push(`${prefix}${count}inc`);
                }
                else if (/^dec(\d*)$/i.test(token)) {
                    let n = token.match(/^dec(\d*)$/i)[1];
                    let count = n ? parseInt(n) + 1 : 2;
                    let prefix = mode === 'normal' ? 'sc' : (mode === 'back' ? 'scbl' : 'scfl');
                    paradeTokens.push(`${prefix}${count}tog`);
                }
                else {
                    paradeTokens.push(token);
                }
            }
            if (inMagicCircle) {
                inMagicCircle=false;
                output.push(`(${paradeTokens.join(', ')})@R`);
            }
            else
            output.push(paradeTokens.join(', '));
            mode = 'normal'; // Reset mode after each row
            continue;
        }
        // Handle rows like "Row 34 [31 st]: 31"
        m = line.match(/^Row\s+\d+\s*\[.*?\]:\s*(\d+)$/);
        if (m) {
            let n = m[1];
            if (mode === 'normal') output.push(`${n}sc`);
            else if (mode === 'back') output.push(`${n}scbl`);
            else if (mode === 'front') output.push(`${n}scfl`);
            mode = 'normal'; // Reset mode after each row
        }
// Handle "fasten off"
m = line.match(/^Row\s+\d+\s*:.*fasten off/i);
        if (m) {
            // Compute N from prevRowTokens
            let N = 0;
            for (let token of prevRowTokens) {
                if (/^\d+$/.test(token)) {
                    N += parseInt(token);
                } else if (/^inc(\d*)$/i.test(token)) {
                    let n = token.match(/^inc(\d*)$/i)[1];
                    N += n ? parseInt(n) + 1 : 2;
                } else if (/^dec(\d*)$/i.test(token)) {
                    N += 1;
                }
            }
            output.push(`sc${N}tog`);
            prevRowTokens = [];
        }
    }
    return output.join('\n');
}


function parseLatheUrl(url) {
    // Parse the URL and extract the data parameter
    const urlObj = new URL(url);
    const dataString = urlObj.searchParams.get('data');
    if (!dataString) throw new Error('No data parameter found in URL.');

    // Split the data into numbers
    const dataArr = dataString.split(',').map(Number);

    // Group into {x, y, dummy}
    let pointsRaw = [];
    for (let i = 0; i < dataArr.length; i += 3) {
        pointsRaw.push({ x: dataArr[i], y: dataArr[i + 1], dummy: dataArr[i + 2] });
    }

    // Find numStitches as the maximum of all x and y
    let maxVal = 0;
    pointsRaw.forEach(pt => {
        maxVal = Math.max(maxVal, pt.x, pt.y);
    });
    const numStitches = maxVal;

    // Scale x and y by dividing by numStitches
    const points = pointsRaw.map(pt => {
        const scaledX = pt.x / numStitches;
        const scaledY = pt.y / numStitches;
        return {
            x: scaledX,
            y: scaledY,
            handleLeft: { x: scaledX, y: scaledY },
            handleRight: { x: scaledX, y: scaledY }
        };
    });

    // Example thicknessPoints (unchanged, as per your sample)
    const thicknessPoints = [
        {"x":0,"y":5,"handleLeft":{"x":0,"y":5},"handleRight":{"x":50,"y":5}},
        {"x":500,"y":5,"handleLeft":{"x":450,"y":5},"handleRight":{"x":550,"y":5}},
        {"x":999,"y":5,"handleLeft":{"x":949,"y":5},"handleRight":{"x":999,"y":5}}
    ];

    // Compose the final JSON
    const result = {
        points: points,
        thicknessPoints: thicknessPoints,
        numStitches: numStitches.toString(),
        scatterShape: true,
        xAxisRange: "1.5",
        yAxisLength: "1.5",
        thicknessB: false
    };

    return result;
}

//// Example usage:
//const url = "data=5.25,0.25,0,5.75,2.75,0,8.75,5.5,0,13,5.5,0,16.5,2.5,0,18.5,2.25,1,21.5,2.25,0,22,0.25,0";
//const jsonResult = parseLatheUrl(url);
//console.log(JSON.stringify(jsonResult, null, 2));

    </script>
    <div>
        <select id="examples">
        </select>
        <span class="radio-buttons">
            <label>
                <input type="radio" name="rendering" value="2D">
                2D
            </label>
            <label>
                <input type="radio" name="rendering" value="3D" checked>
                3D
            </label>
        </span>


        <!-- <div class="dropdown">
         <button class="dropbtn" onclick="toggleDropdown('calculateDropdown')">Calculate</button>
         <div class="dropdown-content" id="calculateDropdown">
             <button class="button" id="3dbutton">Calculate and show model in 3D</button>
         </div>
     </div> -->

        <button class="button" id="3dbutton">Calculate and show model in 3D</button>
        <div class="dropdown">
            <button class="dropbtn" onclick="toggleDropdown('saveOptionsDropdown')">Save/Export &#9660;</button>
            <div class="dropdown-content" id="saveOptionsDropdown">
                <button class="button" onclick="showStats()">Show stats for current project</button>
                <button class="button" onclick="saveTextAsFile()">Save crochet instructions text (best for sharing!)</button>
                <button class="button" onclick="printDiv()">Print crochet instructions with highlights</button>
                <button class="button" onclick="do_saveSvg()">Save Standard Crochet Chart as SVG</button>
                <button class="button" onclick="processToDotFile()">Save file containing nodes and edges</button>
                <button class="button" onclick="do_exportGLTF()">Save 3D model as GLTF file (compatible with Blender)</button>
                <button class="button" onclick="saveDebugInfo()">Save debug info</button>
            </div>
        </div>




        <div class="dropdown">
            <button class="dropbtn" onclick="toggleDropdown('layoutDropdown')">Editor layout &#9660;</button>
            <div class="dropdown-content" id="layoutDropdown">
                <label class="button"><input type="radio" name="layout" value="sideBySide" onclick="toggleLayout('sideBySide')" checked> Side by Side</label>
                <!-- <label class="button"><input type="radio" name="layout" onclick="toggleLayout('stacked')"> Stacked Vertically</label> -->
                <label class="button"><input type="radio" name="layout" value="editorOnly" onclick="toggleLayout('editorOnly')"> Editor Only</label>
                <label class="button"><input type="radio" name="layout" value="3dViewOnly" onclick="toggleLayout('3dViewOnly')"> 3D View Only</label>
            </div>
        </div>
        <div class="dropdown">
            <button class="dropbtn" onclick="toggleDropdown('toolsDropdown')">Tools &#9660;</button>
            <div class="dropdown-content" id="toolsDropdown">
                <button class="button" id="transformButton">Object Transform</button>
                <button class="button" id="latheButton" onclick="lathe()">Convert Crochet Lathe instructions to CrochetPARADE</button>
                <button class="button" id="expandButton" onclick="expandExpression()">Expand instructions</button>
                <button class="button" id="collectButton" onclick="collectExpression()">Simplify instructions</button>
            </div>
        </div>
        <div class="dropdown">
            <button class="dropbtn" onclick="toggleDropdown('helpDropdown')">Help &#9660;</button>
            <div class="dropdown-content" id="helpDropdown">
                <button class="button" onclick="document.getElementById('infoSt').style.display='block'">Built-in stitches</button>
                <button class="button" onclick="document.getElementById('info').style.display='block'">Keyboard shortcuts</button>



                <button class="button" onclick="window.open('./Manual.html', '_blank')">Manual</button>
                <button class="button" onclick="window.open('https://crochetparade.org/crochetforum/forumdisplay.php?fid=3', '_blank')">Ask a question</button>
                <button class="button" onclick="window.open('https://codeberg.org/crochetparade/CrochetPARADE/issues', '_blank')">File a bug report</button>


                <button class="button" onclick="document.getElementById('about').style.display='block'">About</button>
            </div>
        </div>

        <button class="button2" onclick="window.open('https://crochetparade.org/crochetforum/', '_blank')">Forum</button>
        <button class="button1" onclick="window.open('https://donate.stripe.com/eVa6pK4XQ5Qg6vmbII', '_blank')">Leave a Tip</button>


    </div>

    <script>
        var layoutNumber = 0;
        // var layouts = ['sideBySide', 'stacked', 'editorOnly', '3dViewOnly']
        var layouts = ['sideBySide', 'editorOnly', '3dViewOnly'];
        document.addEventListener('keydown', function(event) {
            if ((event.ctrlKey|| event.metaKey) && event.key === 'r') {
                event.preventDefault();
            }
            if ((event.ctrlKey|| event.metaKey) && event.key === 'l') {
                event.preventDefault();
                // Call the function to toggle the layout
                let l = layouts[((++layoutNumber) % 3)];
                toggleLayout(l); // Replace 'sideBySide' with the desired layout

                // Select the corresponding radio button
                //for (let li of layouts)
                //    document.querySelector('input[name="layout"][value=' + li + ']').checked = false;
                document.querySelector('input[name="layout"][value="' + l + '"]').checked = true;
            }
        });

        function toggleDropdown(dropdownId) {
            var dropdown = document.getElementById(dropdownId);
            var dropdowns = document.getElementsByClassName("dropdown-content");
            for (var i = 0; i < dropdowns.length; i++) {
                if (dropdowns[i] !== dropdown && dropdowns[i].classList.contains('show')) {
                    dropdowns[i].classList.remove('show');
                }
            }
            dropdown.classList.toggle("show");
        }

        window.onclick = function(event) {
            if (!event.target.matches('.dropbtn')) {
                var dropdowns = document.getElementsByClassName("dropdown-content");
                for (var i = 0; i < dropdowns.length; i++) {
                    if (dropdowns[i].classList.contains('show')) {
                        dropdowns[i].classList.remove('show');
                    }
                }
            }
        }
    </script>


    <script src="sphere-generator58.js"></script>

    <script>
        var json0 = '';
        var jsonOld = '';
        var reset_json = 1;
        setTimeout(function() {
            const radioButtons = document.querySelectorAll('input[name="rendering"]');

            radioButtons.forEach((radioButton) => {
                radioButton.addEventListener('change', () => {
                    if (radioButton.value === '2D') {
                        DIM = 2;
                    } else if (radioButton.value === '3D') {
                        DIM = 3;
                    }
                });
            });

            var textOptions = [
                ['Write your own instructions', "", 3],
                ['Generate a sphere', null, 3], // New option added
                ['Generate an axially symmetric shape', null, 3], // New option added
                ['Baby bootie (~2sec)', textBootie, 3],
                ['Irish crochet: flower 1 (~1sec)', textFlower2, 2],
                ['Irish crochet: flowers 2 (~5sec)', textFlower, 3],
                ['Granny square (~2sec)', textSquare, 2],
                ['Edging (~1sec)', textEdging, 2],
                ['Planet Earth; large (~1.5min)', textEarth, 3],
                ['Planet Earth; small (~3sec)', textEarthSmall, 3],
                ['Amigurumi: simplistic snowman (~4sec)', textSnowman2, 3],
                ['OLD amigurumi example (~15sec)', textSnowman, 3],
                ['Baby blanket (~7sec)', textBlanket, 3],
                ['Swatch 1 (~8sec)', textSwatch2, 2],
                ['Swatch 2 (~8sec)', textSwatch, 3],
                ['Stocking (~12sec)', textStocking, 3],
                ['Hat (~3min)', textHat, 3],
                ['Mixed styles: lacy hat (~12sec)', textLacyHat, 3],
                ['Filet crochet: logo (~45sec)', textFilet, 3],
                ['Irish crochet: doily (~5min!)', textDoily, 2],
                ['Simple flower with post stitches (~1sec)', textFlower3, 3],
                ['Apple (~4sec)',textApple,3],
                ['Mosaic crochet (~3sec)', textMosaic, 3],
                ['Strawberry stitch (~10sec)', textStrawberries, 3],
                ['Chevron stitch (~4min!)', textChevron, 3],
                ['Waffle stitch (~6sec)',textWaffle,3]
            ];

            var select = document.getElementById('examples');

            var wrapperDiv = document.createElement('div');
            wrapperDiv.style.position = 'relative';
            wrapperDiv.style.display = 'inline-block';

            select.parentNode.replaceChild(wrapperDiv, select);
            wrapperDiv.appendChild(select);

            select.innerHTML = "";

            var defaultOption = document.createElement("option");
            defaultOption.classList.add("button-examples");
            defaultOption.text = textOptions[0][0];
            defaultOption.value = textOptions[0][0];
            select.appendChild(defaultOption);

            for (var i = 1; i < textOptions.length; i++) {
                var option = document.createElement("option");
                option.classList.add("button-examples");
                option.text = textOptions[i][0];
                option.value = textOptions[i][0];
                select.appendChild(option);
            }

            var arrowDiv = document.createElement('div');
            arrowDiv.innerHTML = '&#9660;';
            arrowDiv.style.position = 'absolute';
            arrowDiv.style.right = '4pt';
            arrowDiv.style.top = '6pt';
            wrapperDiv.appendChild(arrowDiv);

            select.onchange = function() {
                
                var inputText = document.getElementById("inputText");
                inputText['expanded']=false;
                var selectedValue = select.value;

                var index = textOptions.findIndex(option => option[0] === selectedValue);
                var selectedNdim = textOptions[index][2];

                if (selectedValue === 'Generate a sphere') {
                    var popup = document.createElement('div');
                    popup.style.position = 'fixed';
                    popup.style.left = '50%';
                    popup.style.top = '50%';
                    popup.style.transform = 'translate(-50%, -50%)';
                    popup.style.backgroundColor = 'white';
                    popup.style.padding = '20px';
                    popup.style.border = '1px solid black';
                    popup.style.zIndex = '1000';

                    popup.innerHTML = `
    <div style="position: relative;">
        <button id="closeButtonSphere" style="position: absolute; top: -10px; right: -10px; background: #f44336; color: white; border: none; border-radius: 0%; width: 24px; height: 24px; cursor: pointer;">×</button>
        <h3>Generate a single-crochet sphere</h3>
        <label for="circumference">Circumference (in stitches; must be between 7 and 1200):</label>
        <input type="number" id="circumference" min="7" value="50"><br><br>
        <label for="scatter">Scatter increases and decreases (reduces symmetric bulges near poles):</label>
        <input type="checkbox" id="scatter" checked><br>
        <br>Note: Pattern uses continuous rounds.<br><br>
        <button id="okButton">Generate</button>
    </div>
`;

                    function removePopup() {
                        document.body.removeChild(popup);
                        select.value = textOptions[0][0];
                    }


                    document.body.appendChild(popup);
                    // Close button action
                    document.getElementById('closeButtonSphere').onclick = removePopup;

                    document.getElementById('okButton').onclick = function() {
                        var Ncirc = parseInt(document.getElementById('circumference').value);
                        if (Ncirc < 7) {
                            Ncirc = 7;
                        }
                        if (Ncirc > 1200) {
                            Ncirc = 1200;
                        }
                        var scatter = document.getElementById('scatter').checked;

                        inputText.value = generate_sphere(Ncirc, scatter);

                        radioButtons.forEach((radioButton) => {
                            if (radioButton.value === '3D') {
                                radioButton.checked = true;
                                DIM = 3;
                            }
                        });

                        document.body.removeChild(popup);

                       
                        update(inputText.value); onMyInput();
                        select.value = textOptions[0][0];
                    };
                } else if (selectedValue === 'Generate an axially symmetric shape') {
                    function exportPoints() {
                        const data = {
                            points: points,
                            thicknessPoints: thicknessPoints,
                            numStitches: document.getElementById('numStitches').value,
                            scatterShape: document.getElementById('scatterShape').checked,
                            xAxisRange: document.getElementById('xAxisRangeDialog').value,
                            yAxisLength: document.getElementById('yAxisLengthDialog').value,
                            thicknessB: document.getElementById('thicknessB').checked
                        };

                        const blob = new Blob([JSON.stringify(data)], {
                            type: 'application/json'
                        });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'CrochetPARADE_axial_shape.json';
                        a.click();
                    }

                    function importPoints() {
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = '.json';
                        input.onchange = function(e) {
                            const file = e.target.files[0];
                            const reader = new FileReader();
                            reader.onload = function(e) {
                                const data = JSON.parse(e.target.result);
                                points = data.points;
                                thicknessPoints = data.thicknessPoints;
                                document.getElementById('numStitches').value = data.numStitches;
                                document.getElementById('scatterShape').checked = data.scatterShape;
                                document.getElementById('xAxisRangeDialog').value = data.xAxisRange;
                                document.getElementById('yAxisLengthDialog').value = data.yAxisLength;
                                document.getElementById('thicknessB').checked = data.thicknessB;
                                drawCurve();
                                drawThicknessCurve();
                                document.getElementById('thicknessB').checked = true;
                                thicknessContainer.style.display = 'block';

                                updateYAxisLength(yAxisLength);
                                updateXAxisRange(xAxisRange);
                            };
                            reader.readAsText(file);
                        };
                        input.click();
                    }

                    // Add event listeners
                    document.getElementById('exportButton').addEventListener('click', exportPoints);
                    document.getElementById('importButton').addEventListener('click', importPoints);
                    //const generateButton = document.getElementById('okayButton');
                    const generatorDialog = document.getElementById('generatorDialog');
                    const numStitchesInput = document.getElementById('numStitches');
                    const yAxisLengthDialogInput = document.getElementById('yAxisLengthDialog');
                    const xAxisRangeDialogInput = document.getElementById('xAxisRangeDialog');
                    const generatorCanvas = document.getElementById('generatorCanvas');
                    const generatorCtx = generatorCanvas.getContext('2d');
                    const okayButton = document.getElementById('okayButton');

                    const contextMenu = document.getElementById('contextMenu');

                    generatorDialog.style.display = 'block';
                    yAxisLengthDialogInput.value = yAxisLength;
                    xAxisRangeDialogInput.value = xAxisRange;
                    updateYAxisLength(yAxisLength);
                    updateXAxisRange(xAxisRange);
                    updateCanvasSize();

                    if (points.length === 0) {
                        resetPoints();
                    } else {
                        drawThicknessCurve();
                        drawCurve();
                    }
                    document.getElementById('clButton').onclick = closeShapeDialog;

                    function closeShapeDialog() {
                        generatorDialog.style.display = 'none';
                        select.value = textOptions[0][0];
                    }
                    okayButton.addEventListener('click', () => {
                        const numStitches = parseInt(numStitchesInput.value);
                        if (isNaN(numStitches) || numStitches <= 0) {
                            alert("Please enter a valid number of stitches.");
                            return;
                        }

                        const newYAxisLength = parseFloat(yAxisLengthDialogInput.value);
                        updateYAxisLength(newYAxisLength);

                        const newXAxisRange = parseFloat(xAxisRangeDialogInput.value);
                        updateXAxisRange(newXAxisRange);

                        const curvePoints = calculateCurvePoints();
                        const interpolateY = createInterpolationFunction(curvePoints);
                        const lengths = calculateCurveLengths(curvePoints);
                        const totalLength = lengths[lengths.length - 1];

                        const numberOfSamples = Math.round(numStitches * totalLength);
                        const deltaL = totalLength / numberOfSamples;
                        shape_radius = [];
                        for (let i = 0; i <= numberOfSamples; i++) {
                            const l_i = i * deltaL;
                            const interpolatedY = interpolateY(l_i);
                            console.log(l_i, interpolatedY * numStitches);
                            shape_radius.push(interpolatedY * numStitches);
                        }
                        console.log(numStitches);

                        generatorDialog.style.display = 'none';
                        let scatter = document.getElementById('scatterShape').checked;
                        inputText.value = generate_shape(scatter);

                        radioButtons.forEach((radioButton) => {
                            if (radioButton.value === '3D') {
                                radioButton.checked = true;
                                DIM = 3;
                            }
                        });

                       
                        update(inputText.value); onMyInput();
                        select.value = textOptions[0][0];
                    });

                } else {
                    inputText.value = textOptions[index][1];
                    radioButtons.forEach((radioButton) => {
                        if (radioButton.value === String(selectedNdim) + 'D') {
                            radioButton.checked = true;
                            DIM = selectedNdim;
                        }
                    });

                    inputText.value = inputText.value.replace(/\t/g, '    ').replace(/\r/g, '')
                   
                    update(inputText.value); onMyInput();
                }
            }
        }, 0);
    </script>

    <div class="editor_container" id="edc">
        <div class="editor" id="ed">
            <div class="numbers" id="nums">
                <span></span>
            </div>
            <div class="hor_scroll" id="hrs" style='position:relative'>

                <div id="textdiv">
                    <textarea placeholder="Enter crochet instructions" id="inputText" rows="20" cols="150" spellcheck="false" oninput="update(this.value); sync_scroll(this);" onscroll="sync_scroll(this);" onkeydown="check_tab(this, event);"></textarea>
                    <div class="language-html" id="highlighting" style="position:relative; white-space:pre"><span style="color:gray">Enter crochet instructions</span></div>
                </div>

            </div>
        </div>
    </div>
    <div id="view3d" class="side-by-side" style="background: rgb(230, 230, 230);;font-size:16pt; 
     justify-content: center; align-items: center;"><b>Getting Started</b><br>
        <iframe width="267" height="150" src="https://www.youtube-nocookie.com/embed/videoseries?si=0an24KsR98Qq0CtQ&amp;list=PLDmfqmiN1WWyEp3MI8ik4IvnMARbm_ZMf" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; " allowfullscreen></iframe>
        <br> Write your crochet pattern instructions in the text field on the left. The instructions should be in the <a href="./Manual.html">CrochetPARADE language</a>.
        <br><br>
        For examples, click on the dropdown menu.
        <br><br> 3D view will be displayed here once the calculation button is pressed. Calculation can take a long time. The computational times in the example names are approximate and are for my laptop. Scale them for your device.<br><br>
        After the model is displayed in this canvas, click on it, and then you can press <span style='font-family:monospace;font-weight:400'>'c'</span> to see the yarn colors, or <span style='font-family:monospace;font-weight:400'>'esc'</span> to reset the view. <br> Pressing <span style='font-family:monospace;font-weight:400'>'ctrl+a'</span> or <span style='font-family:monospace;font-weight:400'>'a'</span> will hide/display stitches incrementally.<br> Pressing <span style='font-family:monospace;font-weight:400'>'r'</span> will automatically rotate the view. <br>
        <br>See the help for more keyboard shortcuts.

    </div>
    <script>

        const textarea = document.getElementById('inputText');

        function findMatchingClosingBracketIndex(str, cursorPos) {
            const openingBrackets = '([{';
            const closingBrackets = ')]}';
            const stack = [];

            for (let i = 0; i < str.length; i++) {
                if (openingBrackets.includes(str[i])) {
                    stack.push(i);
                } else if (closingBrackets.includes(str[i])) {
                    if (stack.length === 0) {
                        return -1; // Unbalanced brackets
                    }
                    const openingIndex = stack.pop();
                    if (openingIndex === cursorPos) {
                        return i; // Match found
                    }
                }
            }

            if (stack.length > 0) {
                return -1; // Unbalanced brackets
            }

            return -1; // No match found
        }


        function getMatchingBracket(Bracket) {
            switch (Bracket) {
                case '(':
                    return ')';
                case '[':
                    return ']';
                case '{':
                    return '}';
                case ')':
                    return '(';
                case ']':
                    return '[';
                case '}':
                    return '{';
                default:
                    return null;
            }
        }

        function findMatchingOpeningBracketIndex(str, cursorPos) {
            const openingBrackets = ')]}';
            const closingBrackets = '([{';
            str = str.split('').reverse().join('');

            const stack = [];

            for (let i = 0; i < str.length; i++) {
                if (openingBrackets.includes(str[i])) {
                    stack.push(i);
                } else if (closingBrackets.includes(str[i])) {
                    if (stack.length === 0) {
                        return -1; // Unbalanced brackets
                    }
                    const openingIndex = stack.pop();
                    if (openingIndex === (str.length - 1) - cursorPos) {
                        return (str.length - 1) - i; // Match found
                    }
                }
            }

            if (stack.length > 0) {
                return -1; // Unbalanced brackets
            }

            return -1; // No match found
        }

        function highlightUnmatchedBrackets(str) {
            const openingBrackets = '([{';
            const closingBrackets = ')]}';
            const stack = [];
            const unmatchedIndices = new Set();

            // First pass: identify unmatched brackets
            for (let i = 0; i < str.length; i++) {
                const char = str[i];
                if (openingBrackets.includes(char)) {
                    stack.push({
                        char,
                        index: i
                    });
                } else if (closingBrackets.includes(char)) {
                    if (stack.length > 0) {
                        const lastOpening = stack[stack.length - 1];
                        if (closingBrackets.indexOf(char) === openingBrackets.indexOf(lastOpening.char)) {
                            stack.pop();
                        } else {
                            unmatchedIndices.add(i);
                            unmatchedIndices.add(lastOpening.index);
                            stack.pop();
                        }
                    } else {
                        unmatchedIndices.add(i);
                    }
                }
            }

            // Add any remaining unmatched opening brackets
            while (stack.length > 0) {
                const unmatchedOpening = stack.pop();
                unmatchedIndices.add(unmatchedOpening.index);
            }

            // Second pass: construct the result string
            let result = '';
            for (let i = 0; i < str.length; i++) {
                if (unmatchedIndices.has(i)) {
                    result += '<span style="background-color:rgb(255, 33, 33)">' + str[i] + '</span>';
                } else {
                    result += str[i];
                }
            }

            return result;
        }

        function findAllUnmatchedBracketIndices(str) {
            const openingBrackets = '([{';
            const closingBrackets = ')]}';
            const stack = []; // To keep track of unmatched opening brackets
            const unmatchedIndices = new Set(); // To store indices of unmatched brackets

            for (let i = 0; i < str.length; i++) {
                const char = str[i];

                if (openingBrackets.includes(char)) {
                    // Push the index and the bracket to the stack
                    stack.push({
                        char,
                        index: i
                    });
                } else if (closingBrackets.includes(char)) {
                    // Check if there's a matching opening bracket
                    if (stack.length > 0) {
                        const lastOpening = stack[stack.length - 1];
                        if (closingBrackets.indexOf(char) === openingBrackets.indexOf(lastOpening.char)) {
                            // Found a match, remove it from the stack
                            stack.pop();
                        } else {
                            // No match, mark this closing bracket as unmatched and pop the last opening
                            unmatchedIndices.add(i);
                            unmatchedIndices.add(lastOpening.index);
                            stack.pop();
                        }
                    } else {
                        // No opening bracket to match, mark this closing bracket as unmatched
                        unmatchedIndices.add(i);
                    }
                }
            }

            // Add any remaining unmatched opening brackets in the stack to the result
            while (stack.length > 0) {
                const unmatchedOpening = stack.pop();
                unmatchedIndices.add(unmatchedOpening.index);
            }

            return Array.from(unmatchedIndices).sort((a, b) => a - b); // Return sorted indices
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        let assignedIds = new Set(); 
        const tooltip = document.createElement('div');
        tooltip.id = 'custom-tooltip';
        document.body.appendChild(tooltip);

function assignIdsAndHover(highlight,resetHighlights) {
    //const highlight = document.getElementById("highlighting");
    //console.log('Numbers='+highlight.querySelectorAll(".token.number").length)
    //return
    const wordTokens = highlight.querySelectorAll(".token.words"); // Select all .token.words spans

    //const brElements = highlight.querySelectorAll("br"); // Select all <br> elements within the highlighting div
    let brElements = Array.from(highlight.querySelectorAll("br")); // Convert NodeList to array
brElements = brElements.filter((br, index) => {
  const nextElement = br.nextElementSibling;
  return !(nextElement && 
          nextElement.classList.contains("special") && 
          nextElement.innerText === "...");
});
    let row = 0; // Line number counter
    let idCounter = 0; // Global ID counter
    let kCounter = 0; // Counter for spans since the last <br>
    const assignedIds = new Set(); // Track assigned IDs to avoid duplicates

    let currentBrIndex = 0; // Index of the current <br> element being processed
    let hasTokenWordsSinceLastBr = false; // Tracks if there are token words since the last <br>

    wordTokens.forEach((span) => {
        if (resetHighlights==1)
            span.style.backgroundColor="";
        else if (resetHighlights==2 &&  span.style.backgroundColor==="yellow")
            span.style.backgroundColor="";
        // Check if this span is before or after a <br> element
        while (
            currentBrIndex < brElements.length &&
            span.compareDocumentPosition(brElements[currentBrIndex]) & Node.DOCUMENT_POSITION_PRECEDING
        ) {
            // If crossing a <br>, check if there were token words before it
            if (hasTokenWordsSinceLastBr) {
                row++; // Increment row number only if there were token words
            }
            currentBrIndex++; // Move to the next <br>
            hasTokenWordsSinceLastBr = false; // Reset token words flag for the next line
            kCounter = 0; // Reset kCounter for spans after a new line
        }

        // If this span is a valid token word, mark it as such
        if (span.textContent.trim() !== "turn") {
            hasTokenWordsSinceLastBr = true; // Mark that we have token words on this line

            const spanText = span.textContent.trim(); // Get the text inside the span
        let diff = 0; // Default diff value
        //console.log(spanText);
        //console.log(Dictionary)
        if (Dictionary.hasOwnProperty(spanText)) {
            // If the string is a key in Dictionary, calculate diff based on top nodes
            const [type, Top] = Dictionary[spanText].slice(1).split(/[\^\:~]/g); // Extract Top
            const topNodes = [...Top.matchAll(/([A-Z0-9a-z_]+)\(/g)].map(match => match[1]); // Extract top node names
            diff = topNodes.length; // Number of top nodes
            //console.log('ft',diff);
        } else if (/\d*inc$/.test(spanText)) {
            // If the string ends with "inc", extract the number and use it as diff
            const match = spanText.match(/(\d*)inc$/);
            diff = match ? parseInt(match[1], 10) : 0;
        } else if (/\d*tog$/.test(spanText)) {
            // If the string ends with "tog", set diff to 1
            diff = 1;
        }

            //if (!span.id) {
                // Assign a new ID only if the span does not already have one
                let newId = `word(${row}|${kCounter})${idCounter}`;
                if (span.textContent.trim() === "sk" || diff==0)
                    newId = `word${idCounter}`;
                span.id = newId;
                assignedIds.add(newId); // Track the new ID to ensure uniqueness
                idCounter++; // Increment global ID counter
                if (span.textContent.trim() !== "sk"&&diff!=0)
                    kCounter+=diff; // Increment kCounter for spans since the last <br>
            //}
        }
    });

    // After processing all spans, check for any remaining token words after the last <br>
    if (hasTokenWordsSinceLastBr) {
        row++; // Increment row number for any remaining token words after the last <br>
    }
}
document.getElementById("inputText").addEventListener("mousemove", (e) => {
  const textarea = e.target;
  const highlighting = document.getElementById("highlighting");

  // Get mouse coordinates relative to viewport
  const mouseX = e.clientX;
  const mouseY = e.clientY;

  // Get highlighting layer's position
  const highlightRect = highlighting.getBoundingClientRect();

  // Translate coordinates to highlighting layer's system
  const relativeX = mouseX - highlightRect.left;
  const relativeY = mouseY - highlightRect.top;

  // Find spans in highlighting layer
  const spans = highlighting.querySelectorAll('.token.words');
  let hoveredSpan = null;

  // Check which span contains the mouse
  spans.forEach((span) => {
    const spanRect = span.getBoundingClientRect();
    const adjustedSpanRect = {
      left: spanRect.left - highlightRect.left,
      top: spanRect.top - highlightRect.top,
      right: spanRect.right - highlightRect.left,
      bottom: spanRect.bottom - highlightRect.top
    };

    if (
      relativeX >= adjustedSpanRect.left &&
      relativeX <= adjustedSpanRect.right &&
      relativeY >= adjustedSpanRect.top &&
      relativeY <= adjustedSpanRect.bottom
    ) {
      hoveredSpan = span;
    }
  });

  // Update tooltip
  var inputText = document.getElementById("inputText");
  if (hoveredSpan && inputText['expanded']) {
    const id = hoveredSpan.id.replace('word', '');
    tooltip.textContent = id;
    tooltip.style.left = `${mouseX + 10}px`;
    tooltip.style.top = `${mouseY + 10}px`;
    tooltip.style.display = 'block';
    textarea.dataset.hoveredId = id; // Store the hovered ID for later use
  } else {
    tooltip.style.display = 'none';
    delete textarea.dataset.hoveredId; // Clear stored ID if no span is hovered
  }
});


document.getElementById("inputText").addEventListener("click", (e) => {
    if ((e.altKey)&&(!(e.ctrlKey|| e.metaKey))){          
          let result_element = document.querySelector("#highlighting");
    assignIdsAndHover(result_element,2);
    triggerClickTextEvent(-1,-1,true);
}
  if (e.ctrlKey|| e.metaKey) { // Check if CTRL key is pressed
    const textarea = e.target;
    const id = textarea.dataset.hoveredId; // Retrieve stored ID from mousemove

    if (id && /\(\d*\|\d*\)\d*/.test(id)) { // Validate ID format using regex
      const match = id.match(/\((\d*)\|(\d*)\)/); // Extract row and kCount using regex groups
      if (match) {
        const row = Number(match[1]); // First group is 'row'
        const kCount = Number(match[2]); // Second group is 'kCount'

        // Highlight the span with the current ID
        const currentSpan = document.getElementById(`word${id}`);
        let reset=false;
        if (currentSpan) {

          // Unhighlight the previously highlighted span (if any)
          if (!(e.altKey)){

  const highlight = document.getElementById("highlighting");
            const wordTokens = highlight.querySelectorAll(".token.words"); 
 wordTokens.forEach((span) => {
if (span.style.backgroundColor==="yellow")
            span.style.backgroundColor="";
        });
        reset=true;
         // Highlight the current span
          
        inputText.previousHighlightedId=[];
        }
        currentSpan.style.backgroundColor = "yellow";
          // Update the dataset to track the currently highlighted span
          inputText.previousHighlightedId.push(id);
        }
        // Trigger the custom event
        triggerClickTextEvent(row, kCount,reset);
      }
    }
  }
});

// Function to dispatch the custom event
function triggerClickTextEvent(row, kCount,reset) {
    const eventData = { row, kCount,reset }; // Data to pass with the event
    const clickTextEvent = new CustomEvent('clickText', { detail: eventData }); // Create the custom event
    document.dispatchEvent(clickTextEvent); // Dispatch the event
}

// 2. Hide tooltip when mouse leaves textarea
document.getElementById("inputText").addEventListener("mouseleave", () => {
  tooltip.style.display = 'none';
});

        function update(text) {
            // Handle final newlines
            let defs = extractWords(text);
            const uniqueResult = [...new Set([...Object.keys(OriginalDictionary), ...defs, 'turn'])];

            // Custom language definition for Prism.js
            Prism.languages.html = {
                //'brokenbracket':[/(\((?=(([^()]|\([^()]*\))*[^)]*$)))|(^([^()]*|\([^()]*\))*)(\))/ ,
                //{pattern:/^(\((\((\((\((\((\((\((\((\((\([^()]*\)|[^()])*\)|[^()])*\)|[^()])*\)|[^()])*\)|[^()])*\)|[^()])*\)|[^()])*\)|[^()])*\)|[^()])*\)|[^()])*\)/,greedy:true
                //}],

              
                'transform': {
//pattern:/^\s*(TRANSFORM_OBJECT:)[^#\\\n]*/m,
pattern:/^\s*TRANSFORM_OBJECT:\s*(\d+),(-?[\d.]+),(-?[\d.]+),(-?[\d.]+),(-?[\d.]+),(-?[\d.]+),(-?[\d.]+)/m
,greedy: true
            },  'comment': {pattern:/\\[^\\]*?(?:\\|$)|#.*/ ,
greedy:true},
                'def': {
                    pattern: /^(\s*)(DEF:.*)/m,
                    lookbehind: true
                },

                'dot1': {
                    pattern: /^\s*(DOT:)\s*(\"(.*)|separate(\s*)=(\s*)[\.\d]+|inflate(\s*)=(\s*)[\.\d]+|learning_rate(\s*)=(\s*)[\.\d]+|start(\s*)=(\s*)\d+|iterations(\s*)=(\s*)\d+|repulsion_radius(\s*)=(\s*)[\.\d]+|viscous_iterations(\s*)=(\s*)\d+|viscous_timestep(\s*)=(\s*)[\.\d]+|viscous_damping(\s*)=(\s*)[\.\d]+)/m,
                    greedy: true
                },
                'dot2': {
                    pattern: /^\s*(DOT:)\s*(\"(.*)|separate|inflate|learning_rate|iterations|start|viscous_damping|viscous_timestep|viscous_iterations|repulsion_radius)(\s*)=?/m,
                    greedy: true
                },
                'dot': {
                    pattern: /^\s*(DOT:)/m,
                    greedy: true
                },
                'color': {
                    pattern: /(BACKGROUND:|COLOR:)(((([^,(\n]*\([^)\n]*\)|[^,(\n])*)))/,
                    greedy: false
                },
                'special': {
                    pattern: /\.{3}|[<>]/,
                    greedy: false
                },
                'labelat': {
                    pattern: /@(?:[^\($\n,\+!\^\*\.\[{\]}\)]*|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*\)|\[(?:[^\[\]]|\[(?:[^\[\]]|\[(?:[^\[\]]|\[(?:[^\[\]]|\[(?:[^\[\]]|\[[^\[\]]*\])*\])*\])*\])*\])*\]|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\})*\})*\})*/, //Match label with @ or .
                    greedy: false
                },
                'labeldot': {
                    pattern: /\.(?:[^\($\n,\*~@\[{\]}\)]*|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*\)|\[(?:[^\[\]]|\[(?:[^\[\]]|\[(?:[^\[\]]|\[(?:[^\[\]]|\[(?:[^\[\]]|\[[^\[\]]*\])*\])*\])*\])*\])*\]|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\})*\})*\})*/,
                    greedy: false
                },
                'dollar': {
                    pattern: /\$.*?\$|\$[^\$\n$]*($|\n)/,
                    greedy: true
                },
                'bracket': {
                    pattern: /[[\](){}]/,
                    greedy: true
                },
                'number': /\b\d+\b|\b\d+(?=[a-zA-Z_])/,
                'punctuation': /[,*]/,
                'words': {
                    pattern: new RegExp(
                        `\\b[0-9]*(?:${uniqueResult.map(escapeRegExp).join('|')}\\b|\\b[0-9]*` +
                        `(?:${uniqueResult.map(escapeRegExp).join('|')})\\d+(?:inc|tog))\\b`,
                        'g'


                    ),
                    greedy: false
                },
                'unknown': {
                    pattern: /\b([a-zA-Z_]+[\d]*)*\b|~|!|\+|\^/
                }
                //,.replaceAll('\n', '<br>')
                //'string': /"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*'/
            };




            if (text[text.length - 1] == "\n") {
                text += " ";
            }

            // Escape HTML entities
            text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            let result_element = document.querySelector("#highlighting");
            //assignIdsAndHover(tempElement);
            // Update code
            const valueLength = inputText.value.length;
const oldTextLength = inputText.dataset.oldText.length;

    // Check if the text has changed
    if (inputText.value !== inputText.dataset.oldText ) {
        // Create a temporary element for highlighting
        
        tempElement.innerHTML =text;
        tempElement.className = result_element.className;
        //result_element.innerHTML = text; 
        // Apply Prism highlighting to the temporary element
        Prism.highlightElement(tempElement);
        let inputString = tempElement.innerHTML.replaceAll('\n', '<br>'); //.replaceAll(' ', '&nbsp;');
        tempElement.innerHTML = highlightUnmatchedBrackets(inputString);
            assignIdsAndHover(tempElement,false);


            if  (Math.abs(valueLength - oldTextLength) <= 10){
        // Compare spans in two sweeps (forward and backward)
        let originalSpans = result_element.querySelectorAll("*");
        let tempSpans = tempElement.querySelectorAll("*");


        // Forward sweep
        if (inputText.expanded){
                    // Backward sweep
                    let forwardIndex = 0;
let backwardIndex = originalSpans.length - 1;
let tempForwardIndex = 0;
let tempBackwardIndex = tempSpans.length - 1;

let forwardStopped = false; // Flag to track if the forward sweep has stopped
let backwardStopped = false; // Flag to track if the backward sweep has stopped

while (forwardIndex <= backwardIndex && tempForwardIndex <= tempBackwardIndex) {
    // Forward sweep (only if it hasn't stopped)
    if (!forwardStopped) {
        if (
            originalSpans[forwardIndex].textContent === tempSpans[tempForwardIndex].textContent
        ) {
            tempSpans[tempForwardIndex].id = originalSpans[forwardIndex].id;
            tempSpans[tempForwardIndex].style.cssText = originalSpans[forwardIndex].style.cssText;
            forwardIndex++;
            tempForwardIndex++;
        } else {
            forwardStopped = true; // Stop the forward sweep
        }
    }

    // Backward sweep (only if it hasn't stopped)
    if (!backwardStopped) {
        if (
            originalSpans[backwardIndex].textContent === tempSpans[tempBackwardIndex].textContent
        ) {
            tempSpans[tempBackwardIndex].id = originalSpans[backwardIndex].id;
            tempSpans[tempBackwardIndex].style.cssText = originalSpans[backwardIndex].style.cssText;
            backwardIndex--;
            tempBackwardIndex--;
        } else {
            backwardStopped = true; // Stop the backward sweep
        }
    }

    // Exit loop if both directions have stopped
    if (forwardStopped && backwardStopped) {
        tempSpans[tempBackwardIndex].id='';
        tempBackwardIndex--;
        tempSpans[tempForwardIndex].id ='';
        tempForwardIndex++;
    };
}
    }

    }

        // Overwrite the original element's content with the updated temporary element's content
        result_element.innerHTML = tempElement.innerHTML;

        // Update old text tracking
        inputText.dataset.oldText = inputText.value;
    }
        }

        // Helper function to escape special characters in regex
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        textarea.addEventListener('input', function() {
            setTimeout(function() {

                update(textarea.value), 0
            });
        })




        textarea.addEventListener('mousedown', function() {
            setTimeout(function() {

                update(textarea.value), 0
            });
        })
        let defs;

        function splitNameAndStr(word) {
            const match = word.match(/^([a-zA-Z]+)(\d+)(.*)$/);
            if (match) {
                return {
                    name: match[1],
                    str: match[3]
                };
            } else {
                return null; // Return null if the word doesn't match the pattern
            }
        }

        function isPositiveIntegerOrZero(word) {
            // Remove any leading or trailing whitespace
            //word = word.trim();

            // Check if the word is a valid positive integer or zero
            return /^\d+$/.test(word) && parseInt(word) >= 0;
        }

        function add_word(word) {
            //console.log(word)
            word1 = word.replace(/\s|&nbsp;/g, '');
            if (word1 === '\n' || word1.length == 0 || isPositiveIntegerOrZero(word1))
                return `<span style="font-weight: 540;"><span style="background-color: transparent;">${word}</span>`;
            //console.log(word1);
            const [, digits, rest] = word.match(/^((?:\d+|\s+|&nbsp;+)*)(.*)$/);
            const [, digits1, rest1] = word1.match(/^(\d*)(.*)$/);
            //console.log('a: ', digits, 'a: ', rest, 'a: ', digits1, 'a: ', rest1);
            if (Dictionary[rest1] || defs.includes(rest1) || word1 === 'turn') {
                //console.log('ok1');
                return `<span style="font-weight: 540;"><span style="background-color: transparent;">${word}</span>`;
            } else {
                let tmp = splitNameAndStr(rest1);
                if (tmp)
                    if (['inc', 'tog'].includes(tmp.str) && (Dictionary[tmp.name] || defs.includes(tmp.name))) {
                        //console.log('ok2');
                        return `<span style="font-weight: 540;"><span style="background-color: transparent;">${word}</span>`;
                    }
                else {
                    //console.log('ok3');
                    return `<span style="font-weight: 540;"><span style="background-color: transparent;">${digits}</span><span style="background-color: rgb(200,100,100);">${rest}</span></span>`;
                } else {
                    //console.log('ok4', digits, ' rest:', rest);
                    return `<span style="font-weight: 540;"><span style="background-color: transparent;">${digits}</span><span style="background-color: rgb(200,100,100);">${rest}</span></span>`;
                }
            }
        }

        function extractWords(input) {

            const regex = /\s*DEF:\s*(\S+)\s*=/g;
            const matches = input.matchAll(regex);
            return Array.from(matches, match => match[1]);
        }



        function sync_scroll(element) {
            /* Scroll result to scroll coords of event - sync with textarea */
            let result_element = document.querySelector("#highlighting");
            // Get and set x and y
            result_element.scrollTop = element.scrollTop;
            result_element.scrollLeft = element.scrollLeft;
        }

        function check_tab(element, event) {
            ///let code = element.value;
            ///if (event.key == "Tab") {
            ///    /* Tab key pressed */
            ///    event.preventDefault(); // stop normal
            ///    let before_tab = code.slice(0, element.selectionStart); // text before tab
            ///    let after_tab = code.slice(element.selectionEnd, element.value.length); // text after tab
            ///    let cursor_pos = element.selectionStart + 4; // where cursor moves after tab - moving forward by 1 char to after tab
            ///    element.value = before_tab + "    " + after_tab; // add tab char
            ///    // move cursor
            ///    element.selectionStart = cursor_pos;
            ///    element.selectionEnd = cursor_pos;
            ///    update(element.value); // Update text to include indent
            ///}
        }

        function onMyInput() {


            const edc = document.getElementById('edc');
            //const textarea = document.getElementById('inputText');
            const numbers = document.querySelector('.numbers');
            if (textarea.value.includes('¶')) {
                let text = '';
                for (var l of textarea.value.split('\n')) {
                    if (l.trim()[0] === '¶') {
                        l = l.trim().slice(1);
                        if ((l.trim().slice(0, 3) === '...'))
                            text += l.trim().slice(3);
                        else
                            text += '\n' + l;
                    } else
                        text += l.trim();
                }
                textarea.value = text.trim();
            }
            textarea.value = textarea.value.replace(/\t/g, '    ').replace(/\r/g, '');
            const lines1 = textarea.value.split('\n');
            let maxLength = 0;

            lines1.forEach((line) => {
                if (line.length > maxLength) {
                    maxLength = line.length;
                }
            });

            //if (maxLength < 140)
            //    maxLength = 140
            textarea.style.width = (maxLength + 3) + 'ch';

            if (textarea.offsetWidth < edc.offsetWidth - 80)
                textarea.style.width = (edc.offsetWidth - 80) + 'px';

            const highlight = document.getElementById('highlighting');
            highlight.style.width = textarea.style.width;

            const textdiv = document.getElementById('textdiv');
            //textdiv.style.width = textarea.style.width

            let tempElement = document.createElement('div');
            tempElement.style.height = '10pt'; // Set the font size in points
            //
            //// Add the temporary element to the document
            document.body.appendChild(tempElement);
            //
            //// Measure the height of the temporary element
            let heightInPixels = tempElement.offsetHeight / 10;
            //
            //// Remove the temporary element from the document
            document.body.removeChild(tempElement);
            //console.log(heightInPixels)

            const H = (window.innerHeight / heightInPixels - 40) / 21;

            var numberOfLineBreaks = (textarea.value.match(/\n/g) || []).length;
            if (numberOfLineBreaks < H)
                numberOfLineBreaks = H;

            //numberOfLineBreaks * 21 + 40;
            const newHeight = numberOfLineBreaks * 21 + 40;
            textarea.style.height = newHeight + 'pt';
            highlight.style.height = textarea.style.height;
            //edc.style.height = textarea.style.height
            //textdiv.style.height = textarea.style.height
            //const firstDiv = document.getElementById('inputText');
            //const firstDivHeight = firstDiv.clienHeight;
            var firstDivHeight = newHeight;
            var secondDiv = document.getElementById('nums');
            secondDiv.style.height = (firstDivHeight - 15 - 21) + 'pt';
            secondDiv = document.getElementById('hrs');
            secondDiv.style.height = firstDivHeight + 'pt';
            secondDiv = document.getElementById('ed');
            secondDiv.style.height = firstDivHeight + 'pt';

            const brElements = highlight.querySelectorAll('br'); // Select all <br> elements within the highlight div.

let numtext = '';
let num = -1;

// Check all elements before brElements[0].
let hasTokenWordsBeforeFirstBr = false;
let sibling = highlight.firstChild; // Start from the first child of the highlight div.

while (sibling && sibling !== brElements[0]) {
    if (sibling.nodeType === 1 && sibling.classList.contains('token') && sibling.classList.contains('words')) {
        hasTokenWordsBeforeFirstBr = true;
        break; // Stop checking further once we find a match.
    }
    sibling = sibling.nextSibling; // Move to the next sibling.
}

if (hasTokenWordsBeforeFirstBr) {
    num++;
    numtext += `<span>${num}<br></span>`;
} else {
    numtext += '<span><br></span>';
}

// Iterate through <br> elements and check siblings between consecutive <br> tags.
for (let i = 1; i < brElements.length; i++) {
    const prevBr = brElements[i - 1]; // Previous <br> element.
    const currentBr = brElements[i]; // Current <br> element.

    let hasTokenWordsBetweenBrs = false;
    let sibling = prevBr.nextElementSibling;

    // Iterate through siblings between prevBr and currentBr.
    while (sibling && sibling !== currentBr  && (!(sibling.classList.contains('special')&&sibling.innerText==='...'))) {
        if (sibling.classList.contains('token') && sibling.classList.contains('words')) {
            hasTokenWordsBetweenBrs = true;
            break; // Stop checking further once we find a match.
        }
        sibling = sibling.nextElementSibling; // Move to the next sibling.
    }

    if (hasTokenWordsBetweenBrs) {
        num++;
        numtext += `<span>${num}<br></span>`;
    } else {
        numtext += '<span><br></span>';
    }
}

// Check for any siblings after the last <br> until the end of the HTML.
const lastBr = brElements[brElements.length - 1];
let hasTokenWordsAfterLastBr = false;
if (lastBr){
sibling = lastBr.nextElementSibling;

while (sibling && (!(sibling.classList.contains('special')&&sibling.innerText==='...'))) {
    if (sibling.classList.contains('token') && sibling.classList.contains('words')) {
        hasTokenWordsAfterLastBr = true;
        break; // Stop checking further once we find a match.
    }
    sibling = sibling.nextElementSibling; // Move to the next sibling.
}
}
if (hasTokenWordsAfterLastBr) {
    num++;
    numtext += `<span>${num}<br></span>`;
} else {
    numtext += '<span><br></span>';
}


            numbers.innerHTML = numtext;

        }

        textarea.addEventListener('input', onMyInput);
    </script>



    <script>
        function processTextSafe(text, json0) {
            if (text.trim() === '') {
                alert('There are no instructions to parse. Write your own or use one of the examples from the drop down menu.');
                //throw new Error('Error during processing of text. See alert box.')
                return '';
            }
            try {
                return processText(text, json0)

            } catch (error) {
                alert(error.message);
                //throw new Error('Error during processing of text. See alert box.')
                return '';
            }
        }

        var scene = null;
        var scene1 = null;
        var exportGLTF;
        var saveSvg;
        var onMouseDown = null;
        var onMouseMove = null;
        var handleKeyDown = null;
        var handleKeyDownHide = null;
        var handleKeyDownHideAnim = null;
        var handleKeyUp = null;
    </script>



    <script>
        function printDiv() {
            var divContents = document.querySelector("#highlighting").innerHTML;
            divContents = '<span style="color:red">&para;</span><span style="color:rgb(128,128,128)>">#Instructions originally written in CrochetPARADE 1.0 language.</span><br><span style="color:red">&para;</span>' + divContents.replaceAll('<br>', '<br><span style="color:red">&para;</span>')
            var printWindow = window.open('', '', 'height=400,width=800');
            printWindow.document.write('<html><head><title>Crochet Instructions</title>');
            printWindow.document.write(`<style>#highlighting { font-family: monospace;
             font-size: 9pt;
             line-height: 14pt;
             tab-size: 2;
             overflow-wrap: break-word; /* For modern browsers */
             word-wrap: break-word; /* For older browsers */}
             /* Custom Prism.js token styles */
        .token.comment {
            font-weight:540;
            color: rgb(128, 128, 128);
        }
        .token.def {
            font-weight:540;
            color: rgb(121, 42, 121);
        }
        .token.dot1 {
            font-weight:540;
            color: rgb(150, 50, 50);
        }

        .token.transform {
            font-weight: 540;
            color: rgb(111, 59, 174);
        }
        .token.dot2 {
            font-weight:540;
            color: rgb(150, 50, 50);
        }
        .token.dot {
            font-weight:540;
            color: rgb(150, 50, 50);
        }

        .token.color {
            font-weight:540;
            color: rgb(193, 124, 15);
        }

        .token.labelat {
            font-weight:540;
            color: rgb(80, 200, 80);
            /* Color for labels starting with @ */
        }

        .token.labeldot {
            font-weight:540;
            color: rgb(37, 170, 226);
            /* Color for labels starting with . */
        }

        .token.special {
            font-weight:540;
            color: rgb(250,0,0);
        }

        .token.dollar {
            font-weight:540;
            color: rgb(40, 160, 150);
        }

        .token.bracket {
            font-weight:540;
            color: blue;
        }

        .token.number {
            font-weight:540;
            color: rgb(153, 0, 79);
        }

        .token.punctuation {
            font-weight:540;
            color: rgb(85, 85, 85);
        }
        
        .token.unknown {
            font-weight:540;
            background-color: #ff2121;
        }

        .token.string {
            font-weight:540;
            color: brown;
        }
        .token.brokenbracket1 {
            font-weight:540;
            background-color: rgb(200, 100, 100);
        }
        .token.brokenbracket {
            font-weight:540;
            background-color: rgb(200, 100, 100);
        } 
        .token.words {
            font-weight:540;
            background-color: rgba(0, 0, 0, 0);
        }
            </style>
             </head>`)
            printWindow.document.write('<body><div id="highlighting">');
            printWindow.document.write(divContents);

            printWindow.document.write('</div></body></html>');
            printWindow.document.close();
            printWindow.print();
        }
    </script>
    <script>
        function saveTextAsFile() {
            var textToWrite = document.getElementById('inputText').value;
            textToWrite = '¶#Instructions originally written in CrochetPARADE 1.0 language.\n¶' + textToWrite.replaceAll('\n', '\n¶')
            var textFileAsBlob = new Blob([textToWrite], {
                type: 'text/plain'
            });
            var fileNameToSaveAs = "instructions.txt";

            var downloadLink = document.createElement("a");
            downloadLink.download = fileNameToSaveAs;
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.click();
        }
    </script>
    <div id="about" class="info-box">
        <span class="close-btn" onclick="document.getElementById('about').style.display='none'" style="float: right; cursor: pointer;">&times;</span>
        <h2 style="font-weight:400">About</h2>
        <p>CrochetPARADE (Crochet PAttern Renderer, Analyzer, and DEbugger) is a
            platform that allows users to create, visualize, and analyze both 2D and 3D crochet patterns.
        </p>
        <p>OVERVIEW</p>
        <p>
            CrochetPARADE uses a custom language grammar that allows users to define stitches and stitch patterns.
            The CrochetPARADE
            grammar aims
            to ensure accuracy and precision in the crochet pattern instructions, avoiding the ambiguities
            encountered with instructions
            in plain English. The code parses and checks any user provided pattern for correctness and
            then creates a virtual model of the project, which is then rendered in 3D.
        </p>
        <p>
            After rendering a pattern, users can review ('debug') the final project's
            shape and make adjustments. The platform identifies overly loose or tight
            stitches, enabling users to replace them with more suitable ones before crocheting,
            thus reducing the need for blocking.
        </p>
        <p>
            CrochetPARADE's export feature allows users to export an automatically generated crochet chart of their project using standard crochet symbols. One can also export an SVG image that
            shows stitch connections and identifies stitches by their type, row number, and position within a row.
            The SVG pattern shows the same information as standard crochet diagrams and can be used as an alternative guide when crocheting.
            Users can also export projects to 3D files that can be imported in
            <a href="https://www.blender.org">Blender</a> for further manipulation and visualization.
        </p>
        <p>
            CrochetPARADE includes interactive features such as the ability to rotate, zoom, and pan the 3D view, as well as
            animating the pattern creation
            process, which can help in visualizing how stitches attach to each other.
            Additional features include highlighting and hiding selected stitches, and
            changing yarn thickness and color.
            Users can access stitch information by hovering over stitches in the 3D view.
        </p>
        <p>CrochetPARADE performs all calculations locally on your device, ensuring
            that no data is collected to a central server or
            transmitted over the internet. As a side effect, the platform can be sluggish on old hardware.
            Models of patterns involving (tens of) thousands of stitches can take minutes or more to calculate.
        </p>
        <p>GOALS AND POSSIBLE APPLICATIONS</p>
        <ul>
            <li>The main goal of CrochetPARADE is to facilitate crochet project design and execution.
            </li>
            <li>Patterns created with CrochetPARADE can be easily shared,
                ensuring they are free from ambiguities or typographic mistakes.
                Creators can simply copy and paste the pattern text to share it,
                and others can use the CrochetPARADE platform to render the shared text into a model of the pattern
                exactly as intended by the pattern author.
            </li>
            <li>CrochetPARADE can be used in education to teach crocheting but also programming skills, since the CrochetPARADE grammar
                follows rules similar to those of real programming languages.
            </li>
            <li>The virtual models created by CrochetPARADE can be imported in 3D modelling and CGI software. Picture an animated movie where characters
                wear crochet hats and sweaters that match real-world crochet projects.
            </li>
            <li>It is probably inevitable that the grammar along with the renderer can
                allow AI to learn how to write
                correct crochet instructions of complicated patterns (beyond simple amigurumi)
                based on general project descriptions.
            </li>
        </ul>
        <p> LICENSE AND COPYRIGHT
            <ul>
                <li>The website and all of its computational components are free and open source and are released under
                    the <a href="https://www.gnu.org/licenses/gpl-3.0.en.html#license-text">GPLv3 license</a>. This ensures that the
                    platform will be free and open to all in perpetuity.
                </li>
                <li>The showcase patterns are either in the public domain (as specified in the pattern description)
                    or are created by the author and are released in the public domain. </li>
                <li>The user manual which includes
                    a description of the CrochetPARADE grammar is released under the
                    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons BY-NC-SA</a> license.
                    The grammar itself cannot be copyrighted and, as any language, is in the public domain.</li>
            </ul>
        </p>
        <p>ACKNOWLEDGEMENTS</p>
        <p>CrochetPARADE uses the following libraries: <a href="https://svgjs.dev/">SVG.js</a>,
            <a href="https://threejs.org/">three.js</a> and <a href="https://prismjs.com">PrismJS</a>.
        </p>
        <p>AUTHOR</p>
        <p>Svetlin Tassev (2023)</p>
    </div>

    <div id="info" class="info-box">
        <span class="close-btn" onclick="document.getElementById('info').style.display='none'" style="float: right; cursor: pointer;">&times;</span>
        <h2 style="font-weight:400">Key bindings</h2>
        <p> General shortcuts.</p>
        <p>
            <ul>
                <li><kbd>ctrl+l</kbd>: Toggle layouts.</li>
            </ul>
        </p>
        <p> Shortcuts in the text input area.</p>
        <p>
            <ul>
                <li><kbd>shift+Enter</kbd>: Calculate positions of all stitches.
                <li><kbd>ctrl+Enter</kbd> (experimental!): Keep positions of already placed stitches. Then calculate positions of newly added stitches since last calculation. Speeds up calculation, but results will be poorer than rerunning whole calculation by pressing on "Calculate..." button or pressing <kbd>shift+Enter</kbd>.</li>
                <li><kbd>ctrl+r</kbd> (experimental!): Same as the previous one, but recalculates only the positions calculated last time the calculation was run. So, it undoes the last calculation and restarts the calculation with the new stitches only. Speeds up code, but will lead to poorer results than rerunning the whole calculation again.</li>
                <li><kbd>left ctrl+left click</kbd>: If the instructions were
                    expanded by running "Expand instructions" from the Tools menu with "Run this dialog twice in a row?" selected, then ctrl+click in the text input on a stitch highlights the selected stitch in the editor and in the 3d canvas simultaneously, removing previous highlights.
                </li>
                <li><kbd>left ctrl+left alt+left click</kbd>: If the instructions were
                    expanded by running "Expand instructions" from the Tools menu with "Run this dialog twice in a row?" selected, then ctrl+click in the text input on a stitch highlights the selected stitch in the editor and in the 3d canvas simultaneously. Unlike ctrl+click, this shortcut does not remove previous highlights.
                </li>
                <li><kbd>left alt+left click</kbd>: Clears previous highlights in the editor and 3d canvas.
            </ul>
            <p> Shortcuts in 3D view. To activate, click on the 3D canvas first.</p>
            <p>
                <ul>
                    <li><kbd>left click and drag</kbd>: Rotate view.</li>
                    <li><kbd>scroll wheel</kbd>: Zoom.</li>
                    <li><kbd>(right click and drag)</kbd> or <kbd>(shift and left click and drag)</kbd>: Pan view.</li>
                    <li><kbd>a</kbd>: Show stitches one by one.</li>
                    <li><kbd>ctrl+a</kbd>: Hide stitches one by one.</li>
                    <li><kbd>c</kbd>: Show project colors. Gray is default if no colors are specified.</li>
                    <li><kbd>esc</kbd>: Reset visibility and colors of stitches.</li>
                    <li><kbd>ctrl+esc</kbd>: Hide all but the first stitch.</li>
                    <li><kbd>ctrl+f</kbd>: Highlight row (by entering: row number) or stitch (by entering: row number, stitch number; for example, "2,4"). Leaving the row number blank (as in ",N") will highlight the N-th stitch of every row. For example, if you enter ",0" that will highlight the beginning of each row.</li>
                    <li><kbd>ctrl+d</kbd>: Highlight stitch or group of stitches with a specific label. One can also select a collection of labels if any. As an example, a collection of labels may be called 'c[ , ]' and if selected, it will highlight all stitches having labels such as 'c[0,1]', 'c[1,2]', etc. with a whitespace being a placeholder.</li>
                    <li><kbd>ctrl+h</kbd>: Hide after row or stitch.</li>
                    <li><kbd>ctrl +/-</kbd>: increase/decrease radii of spheres and cylinders. Affects exported GLTF file as well.</li>
                    <li><kbd>i</kbd>: Toggle visibility of stitch information box.</li>
                    <li><kbd>shift+left click</kbd>: Toggle persistence of stitch information box.</li>
                    <li><kbd>left ctrl+left click</kbd>: If the instructions were
                        expanded by running "Expand instructions" from the Tools menu with "Run this dialog twice in a row?" selected, then ctrl+click in the 3D canvas on a stitch highlights the selected stitch in the editor and in the 3d canvas simultaneously, removing previous highlights.
                    </li>
                    <li><kbd>left ctrl+left alt+left click</kbd>: If the instructions were
                        expanded by running "Expand instructions" from the Tools menu with "Run this dialog twice in a row?" selected, then ctrl+click in the 3D canvas on a stitch highlights the selected stitch in the editor and in the 3d canvas simultaneously. Unlike ctrl+click, this shortcut does not remove previous highlights.
                    </li>
                    <li><kbd>left alt+left click</kbd>: Clears previous highlights in the editor and 3d canvas.
                    </li>
                    <li><kbd>p</kbd>: Write crochet chart to SVG file. For 2D projects, it shows a face-on view. For 3D projects, it shows an orthographic projection from the current view.</li>
                    <li><kbd>r</kbd>: Rotate view automatically.</li>
                    <li><kbd>o</kbd>: Rotate view a tiny amount and save crochet chart SVG corresponding to that view (only for 3D models!). Repeatedly pressing <kbd>o</kbd> leads to saving multiple charts for different views while model is rotating. Useful for creating videos of rotating 3D crochet charts. Resolution is specified only the first time key is pressed.</li>
                    <li><kbd>s</kbd>: Highlight over/under-stretched stitches. Blue for stitches that are too loose, and red for stitches that are too stretched (by more than about 15%) relative to their baseline height. The rest are shown in gray.</li>
                    <li><kbd>v</kbd>: Toggle visibility of arrowheads.</li>
                </ul>
            </p>
    </div>
    <div id="infoSt" class="info-box">
        <span class="close-btn" onclick="document.getElementById('infoSt').style.display='none'" style="float: right; cursor: pointer;">&times;</span>
        <h2 style="font-weight:400">Built-in stitches and special commands</h2>

        <table border="1" cellpadding="5" cellspacing="0">
            <tr>
                <th>Stitch Name</th>
                <th>Description</th>
            </tr>
            <tr>
                <td><code>ch</code></td>
                <td>Chain stitch, the foundation for many crochet projects</td>
            </tr>
            <tr>
                <td><code>ss</code></td>
                <td>Slip stitch, used to join rounds or move across stitches without adding height</td>
            </tr>
            <tr>
                <td><code>sc</code></td>
                <td>Single crochet, a basic stitch that creates a tight, sturdy fabric</td>
            </tr>
            <tr>
                <td><code>hdc</code></td>
                <td>Half double crochet, taller than a single crochet but shorter than a double crochet</td>
            </tr>
            <tr>
                <td><code>dc</code></td>
                <td>Double crochet, a tall stitch that creates an open, airy fabric</td>
            </tr>
            <tr>
                <td><code>tr</code></td>
                <td>Treble crochet, a very tall stitch that creates an even more open fabric</td>
            </tr>
            <tr>
                <td><code>dtr</code></td>
                <td>Double treble crochet, an extra tall stitch for very open, lacy patterns</td>
            </tr>
            <tr>
                <td><code>trtr</code></td>
                <td>Triple treble crochet, an extremely tall stitch for creating dramatic height</td>
            </tr>
            <tr>
                <td><code>rsc</code></td>
                <td>Reverse single crochet, also known as crab stitch, creates a decorative edging</td>
            </tr>
            <tr>
                <td><code>bp...</code> (e.g., <code>bpsc</code>, <code>bphdc</code>, <code>bpdc</code>, <code>bptr</code>)</td>
                <td>Back post stitches, worked behind the post of the stitch below for texture</td>
            </tr>
            <tr>
                <td><code>fp...</code> (e.g., <code>fpsc</code>, <code>fphdc</code>, <code>fpdc</code>, <code>fptr</code>)</td>
                <td>Front post stitches, worked around the post of the stitch below for texture</td>
            </tr>
            <tr>
                <td><code>...fl</code> (e.g., <code>scfl</code>, <code>ssfl</code>, <code>dcfl</code>, <code>hdcfl</code>, <code>trfl</code>, <code>dtrfl</code>, <code>trtrfl</code>)</td>
                <td>Stitches worked in front loop only, creating a horizontal ridge on the back of the work</td>
            </tr>
            <tr>
                <td><code>...bl</code> (e.g., <code>scbl</code>, <code>ssbl</code>, <code>dcbl</code>, <code>hdcbl</code>, <code>trbl</code>, <code>dtrbl</code>, <code>trtrbl</code>)</td>
                <td>Stitches worked in back loop only, creating a horizontal ridge on the front of the work</td>
            </tr>
            <tr>
                <td><code>hdcNpuff</code> (<code>hdc3puff</code>, <code>hdc4puff</code>, <code>hdc5puff</code>)</td>
                <td>Half double crochet puff stitch made with N loops, where N is typically 3, 4, or 5</td>
            </tr>
            <tr>
                <td><code>dcNbobble</code> (<code>dc3bobble</code>, <code>dc4bobble</code>, <code>dc5bobble</code>)</td>
                <td>Double crochet bobble stitch made with N stitches, where N is typically 3, 4, or 5</td>
            </tr>
            <tr>
                <td><code>tr4bobble</code></td>
                <td>Treble crochet bobble stitch made with 4 stitches</td>
            </tr>
            <tr>
                <td><code>dcNpc</code> (<code>dc3pc</code>, <code>dc4pc</code>, <code>dc5pc</code>)</td>
                <td>N-double crochet popcorn stitch, where N is typically 3, 4, or 5</td>
            </tr>
            <tr>
                <td><code>picot3</code></td>
                <td>A decorative loop made with 3 chain stitches and a slip stitch</td>
            </tr>
            <tr>
                <td><code>longsc</code>, <code>longdc</code>, <code>longtr</code></td>
                <td>Long sc/dc/tr, worked into a stitch in a previous row for added height</td>
            </tr>
            <tr>
                <td><code>ring</code></td>
                <td>A magic ring, forming a circular/point-like foundation for crochet projects</td>
            </tr>
            <tr>
                <td><code>stitch_nameNinc</code>, <code>stitch_nameNtog</code></td>
                <td>CrochetPARADE can handle automatically stitch increases and decreases with <code>stitch_nameNinc</code> and <code>stitch_nameNtog</code>, respectively. Here <code>N</code> is an integer denoting the number of stitches of the increase or decrease. For example: <code>sc2inc</code> corresponds to two single-crochet stitches worked into the same stitch; and <code>sc2tog</code> implies that one is doing a decrease by combining two single-crochet stitches.</td>
            </tr>
            <tr>
                <td><code>sk</code></td>
                <td>Skip stitch, used to create spaces or shape in the pattern</td>
            </tr>
            <tr>
                <td><code>tie_up</code></td>
                <td>Special command: ties up stitches -- used to secure yarn end at end of project.</td>
            </tr>
            <tr>
                <td><code>start_at</code></td>
                <td> Special command: creates a hidden stitch used to mark the starting point of a round or row. This marks starting with a new piece of yarn at a specified location in the project. Needs to be followed by a location, e.g. <code>start_at@[-1,0]</code></td>
            </tr>
            <tr>
                <td><code>start_anew</code></td>
                <td>Special command: creates a hidden stitch indicating the beginning of a new section or pattern of a disjoint piece.</td>
            </tr>
            <tr>
                <td><code>start_a_new_chain</code></td>
                <td>Special command: Begins a new chain of stitches, often used to start a new row or section of a disjoint piece.</td>
            </tr>
            <tr>
                <td><code>turn</code></td>
                <td>Special command: <code>turn</code> for turning the work at the end of a row or round. (See "Direction of sequential stitch attachment." for more details.)</td>
            </tr>
            <tr>
                <td><code>...</code></td>
                <td>Special command: Ellipsis (<code>...</code>) in the beginning of a new line indicates the previous line is continued on the current line.</td>
            </tr>
            <tr>
                <td><code>&lt;</code><br><code>&gt;</code></td>
                <td>Special commands: These indicate a repetition starts/ends at that symbol. Example: 3*[sc,&lt;,ch,&gt;,dc] translates to [ch,dc],[sc,ch,dc],[sc,ch]</td>
            </tr>
            <tr>
                <td><code>.</code><br><code>@</code><br><code>~^!</code></td>
                <td>Special commands: Indicate a labeled stitch, attachment to a label/stitch, and modifiers, respectively. Example: sc.A,dc@A (see "Attachment to a label" in the Manual) </td>
            </tr>
            <tr>
                <td><code>#comment</code><br><code>\comment\</code></td>
                <td>Special commands: Allows inserting comments. The pound symbol indicates a comment that extends to the end of the line. Comments enclosed between backslashes can span multiple lines. </td>
            </tr>
            <tr>
                <td><code>COLOR:</code><br><code>BACKGROUND:</code>
                <td>Special commands: COLOR indicates the color of the yarn that follows, while BACKGROUND - the color of the background of the 3D rendering. See the Manual for allowed colors.</td>
            </tr>
            <tr>
                <td><code>TRANSFORM_OBJECT:</code>
                <td>Special commands: Automatically generated by the "Object Transform" tool, which interactively allows the user to move and rotate objects. </td>
            </tr>
            <tr>
                <td><code>DOT:</code>
                <td>Special commands: Any extra arguments to the physics engine. Some options that can be set here are: iterations, start, separate, inflate, learning_rate. Also, new nodes can be created and placed at particular 3D coordinates; and new connections between nodes can be specified here. See the DOT Command section in the Manual. </td>
            </tr>
        </table>
    </div>



    <div id="dialog-box" style="display: none;position: absolute;
     top: 0%;
     margin-top:0;
     left: 50%;
     transform: translate(-50%, 0%);">
        <div id="dialog-content" style="
         padding: 20px;
         background-color: #f2f2f2;
         border: 1px solid #ccc;
         z-index: 1;">
            <span class="close-btn" onclick="closeDialog()" style="float: right; cursor: pointer;">&times;</span>
            <pre id="dialog-text"></pre>
        </div>
    </div>

    <script>
        function showStats() {
            var text = 'Information about the current project.\n\nStitch count per row:\n';
            var [dot, _] = processTextSafe(inputText.value, json0);
            if (dot !== '') {
                for (var row of Object.keys(STATS)) {
                    text += "Row " + row + ": ";
                    var x = Object.keys(STATS[row]);
                    x.sort();
                    for (var st of x) {
                        text += STATS[row][st] + " " + st + ", ";
                    }
                    text = text.slice(0, -2) + "\n";
                }
                text += STATSstretch;
                text += '\n'

                let dict = {}
                for (var row of Object.keys(STATS))
                    for (var k of Object.keys(STATS[row]))
                        dict[k] = Dictionary[k];
                text += 'Dictionary of stitches used for this project:\n';
                for (let k of Object.keys(dict))
                    text += k + '=' + dict[k] + '\n';

                document.getElementById('dialog-text').textContent = text.replace(/\n/g, '\r\n');
                document.getElementById('dialog-box').style.display = 'block';
            }
        }

        function closeDialog() {
            document.getElementById('dialog-box').style.display = 'none';
        }
    </script>

    <script>
        var Module = {
            onRuntimeInitialized: function() {
                //  callPerformLayout();
            }
        };
    </script>
    <script async src="./graph3.js"></script>
    <script>
        function transformJsonWithPos(inputJson, inputJson2) {
            const data = JSON.parse(inputJson);
            const posData = JSON.parse('{"elements":' + inputJson2 + '}');
            //console.log(data)
            //console.log(posData)

            const objects = data.elements.filter(element => element.type === 'node').map((node, index) => {
                const posInfo = posData.elements.find(item => item.name === node.name);
                let atLabel = [];
                if ('attachmentLabel' in node)
                    atLabel = node.attachmentLabel;
                //console.log(atLabel);
                return {
                    _gvid: index,
                    name: node.name,
                    attachmentLabel: atLabel,
                    label: node.label,
                    pos: posInfo ? posInfo.pos : "",
                };
            });

            const nodesMap = {};
            objects.forEach(obj => {
                nodesMap[obj.name] = obj._gvid;
            });

            const edges = data.elements.filter(element => element.type === 'edge').map((edge, index) => ({
                tail: nodesMap[edge.tail],
                head: nodesMap[edge.head],
                color: edge.color,
                label: edge.label,
                len: edge.len,
                penwidth: edge.penwidth
            }));

            const transformedJson = {
                objects: objects,
                edges: edges
            };

            return transformedJson;
        }

        function performLayoutAsync(dot_simple) {
            return new Promise((resolve, reject) => {
                let inputLength = lengthBytesUTF8(dot_simple);
                let inputPointer = Module._malloc(inputLength + 1);
                Module.stringToUTF8(dot_simple, inputPointer, inputLength + 1);
                let resultPointer = Module.ccall('performLayout', 'number', ['number'], [inputPointer]);
                let result = Module.UTF8ToString(resultPointer);
                var json1 = '[' + result.slice(0, -1) + ']';
                json1 = json1.replace('"},]', '"}]');
                Module._free(inputPointer);
                DEBUG += '=======JSON1:=======\n' + JSON.stringify(json1) + '\n';
                resolve(json1);
            });
        }


    </script>
    <script type="module">

        import Generate3DModel from './mesh58.js';
         //import  "./viz-standalone.js";
         const button = document.getElementById("3dbutton");
         //const textarea = document.getElementById('inputText');
    
         textarea.addEventListener('keydown', function(event) {
 
             if ((event.ctrlKey || event.metaKey) && event.key === 'r') {
                 event.preventDefault();
                 reset_json = 3;
 
                 show3DModel();
                 reset_json = 1;
             } else if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                 event.preventDefault();
                 reset_json = 2;
                 show3DModel();
                 reset_json = 1;
             } else if ((event.shiftKey) && event.key === 'Enter') {
                 event.preventDefault();
                 reset_json = 1;
                 show3DModel();
 
             } else {
                 setTimeout(function() {
                     update(textarea.value);
                 }, 0);
             }
         });
 
         async function show3DModel() {
            let result_element = document.querySelector("#highlighting");
            if (result_element.querySelectorAll(".token.number").length>0){
                
                const wordTokens = result_element.querySelectorAll(".token.words"); // Select all .token.words spans
                tooltip.style.display = 'none';
                delete textarea.dataset.hoveredId; 
                wordTokens.forEach((span) => {
                   span.style.backgroundColor="";
                   span.id="";
                });
                textarea['expanded']=false;
            }else{
                textarea['expanded']=true;
                assignIdsAndHover(result_element,1);
                
            }
             var loadingIcon = document.getElementById('loading-icon');
             loadingIcon.style.display = 'block';

    
 
             document.removeEventListener('mousemove', onMouseMove);
             document.removeEventListener('mousedown', onMouseDown);
             document.removeEventListener('keydown', handleKeyDown);
             document.removeEventListener('keydown', handleKeyDownHide);
             document.removeEventListener('keydown', handleKeyDownHideAnim);
             document.getElementById("view3d").innerText = '';
 
             document.removeEventListener('keyup', handleKeyUp);
             var select = document.getElementById("examples");
             var inputText = document.getElementById("inputText");
 
             if (reset_json == 1) { //default
                 jsonOld = '';
                 json0 = '';
             } else if (reset_json == 2) { //continue ctrl+c
                 jsonOld = json0;
             } else if (reset_json == 3) { //repeat ctrl+r
                 json0 = jsonOld;
             }
 
             var dot_simple;
             setTimeout(function() {
                 [json0,dot_simple] = processTextSafe(inputText.value, json0);
             }, 0);
             setTimeout(async function() {
                 //json0 = processTextSafe(inputText.value, json0)
                 //console.log(dot_simple)
                 //console.log(json0)
 
                 if (json0 !== '') {
 
                     //let inputLength = lengthBytesUTF8(dot_simple);
                     //let inputPointer = Module._malloc(inputLength + 1);
                     //Module.stringToUTF8(dot_simple, inputPointer, inputLength + 1);
                     //let resultPointer = Module.ccall('performLayout', 'number', ['number'], [inputPointer]);
                     //let result = Module.UTF8ToString(resultPointer);
                     //var json1 = '[' + result.slice(0, -1) + ']';
                     //json1 = json1.replace('"},]', '"}]')
                     ////console.log(json1);
                     //Module._free(inputPointer);
                     ////console.log(json0)
                     //DEBUG += '=======JSON1:=======\n' + JSON.stringify(json1) + '\n'
 
                     try {
                         var json1 = await performLayoutAsync(dot_simple);
                         json0 = transformJsonWithPos(json0, json1);
                     } catch (error) {
                         // Handle error if needed
                         console.error(error);
                     } finally {
                         loadingIcon.style.display = 'none';
                     }
                     //          console.log(json0)
 
                     // Hide the loading icon once the code has finished running
 
                     DEBUG += '=======JSON0:=======\n' + JSON.stringify(json0) + '\n'
 
                     var a = Generate3DModel(json0, renderer, scene, scene1, backgroundColor,c_was_pressed,factor_radius,requestedInfo)
                     renderer = a[0];
                     scene = a[1];
                     onMouseDown = a[2];
                     onMouseMove = a[3];
                     handleKeyDown = a[4];
                     handleKeyUp = a[5];
                     STATSstretch = a[6];
                     handleKeyDownHide = a[7];
                     handleKeyDownHideAnim = a[8];
                     exportGLTF = a[9];
                     scene1 = a[10];
                     saveSvg = a[11];
                     readInstructions=a[12];
                     updateTextArea=a[13];
                     //loadingIcon.style.display = 'none';
 
                     //});
                 }
                 loadingIcon.style.display = 'none';
                 readInstructions();
             }, 0);
            
         }
 
         button.addEventListener("click", show3DModel);
     </script>

    <script>
        function do_exportGLTF() {
            try {
                exportGLTF();
            } catch (error) {
                alert('You need to press "Calculate model in 3D" first to calculate model.');
            }
        }

        function do_saveSvg() {
            try {
                saveSvg();
            } catch (error) {
                alert('You need to press "Calculate model in 3D" first to calculate model.');
            }
        }

        //var dot;



        function processToDotFile() {
            var text = document.getElementById("inputText").value;
            var [_, dot] = processTextSafe(text, json0);
            if (dot !== '') {
                var file = new Blob([dot], {
                    type: "text/plain"
                });
                var a = document.createElement("a");
                a.href = URL.createObjectURL(file);
                a.download = "crochet.dot";
                a.click();
            }
        }



        function saveDebugInfo() {
            var file = new Blob([DEBUG], {
                type: "text/plain"
            });
            var a = document.createElement("a");
            a.href = URL.createObjectURL(file);
            a.download = "debug.txt";
            a.click();
        }
    </script>



    <script>
        //const view = document.getElementById('view3d');
        //view.classList.add('stacked');
        const editor = document.getElementById('edc');
        const view = document.getElementById('view3d');

        editor.classList.remove('side-by-side', 'stacked');
        view.classList.remove('side-by-side', 'stacked');

        editor.classList.add('side-by-side');
        view.classList.add('side-by-side');

        function toggleLayout(layout) {
            const editor = document.getElementById('edc');
            const view = document.getElementById('view3d');
            editor.classList.remove('side-by-side', 'stacked');
            view.classList.remove('side-by-side', 'stacked');
            editor.style.display = 'block';
            view.style.display = 'block';
            switch (layout) {
                case 'sideBySide':
                    editor.classList.add('side-by-side');
                    view.classList.add('side-by-side');
                    break;
                case 'stacked':
                    editor.classList.add('stacked');
                    view.classList.add('stacked');
                    break;
                case 'editorOnly':

                    editor.classList.add('stacked');
                    view.classList.add('stacked');
                    editor.style.display = 'block';
                    view.style.display = 'none';
                    break;
                case '3dViewOnly':

                    editor.classList.add('stacked');
                    view.classList.add('stacked');
                    editor.style.display = 'none';
                    view.style.display = 'block';
                    break;
                default:
                    break;
            }
        }
        textarea.value = ''
        onMyInput()
    </script>

    <script>
        // Create the loading icon element
        //var tmp=document.getElementById('loading-icon')
        //if (tmp)
        //tmp.parentNode.removeChild(tmp)
        const loadingIcon = document.createElement('div');
        loadingIcon.setAttribute('id', 'loading-icon');
        loadingIcon.innerHTML = 'Calculating... This may take up to a few minutes.';

        // Add the loading icon to the HTML


        // Set the CSS properties for the loading icon
        loadingIcon.style.position = 'fixed';
        loadingIcon.style.top = '50%';
        loadingIcon.style.left = '50%';
        loadingIcon.style.transform = 'translate(-50%, -50%)';
        loadingIcon.style.backgroundColor = 'white';
        loadingIcon.style.padding = '10px';
        loadingIcon.style.fontSize = '30pt';
        loadingIcon.style.display = 'none';
        loadingIcon.style.zIndex = '1000';

        // Show the loading icon before running the code
        document.body.appendChild(loadingIcon);
        loadingIcon.style.display = 'none';
        document.addEventListener('myEvent', function(event) {
            [c_was_pressed, factor_radius, requestedInfo] = event.detail;
        });
        
        inputText['expanded']=false
        inputText.dataset.oldText=inputText.value;
        if (!inputText.previousHighlightedId) {
    inputText.previousHighlightedId = []; // Initialize as an empty array
    inputText.previousHighlightedIdMesh=[];
}

    </script>
</body>

</html>
