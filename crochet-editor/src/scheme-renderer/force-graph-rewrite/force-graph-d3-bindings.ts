/* eslint-disable @typescript-eslint/no-explicit-any */
import * as d3 from "d3-force";
import { type Force } from "d3-force";

import { Observable } from "./utils/observable";
import { debounce } from "./utils/debounce";

const noop = () => {}


export type GraphNode = {
  id: number;
  links: GraphLink[];
  neighbors: GraphNode[];

  // Autogenerated by d3-force (inplace)
  x: number;
  y: number;
  vx: number;
  vy: number;
  fx?: number;
  fy?: number;

  [key: string]: any;
};

export type GraphLink = {
  id: number;
  source: GraphNode;
  target: GraphNode;

  [key: string]: any;
};

export type InitialGraphData = {
  nodes: {
    id: number;
    [k: string]: any;
  }[];
  links: {
    source: number;
    target: number;
    [k: string]: any;
  }[]
};
export type GraphData = {
  nodes: GraphNode[];
  links: GraphLink[];
};

export const d3ForceCenter = () => d3.forceCenter();
export const d3ForceCollide = () => d3.forceCollide();
export const d3ForceLink = () => d3.forceLink();
export const d3ForceManyBody = () => d3.forceManyBody();


export class D3Bindings {
  private readonly linkForces: ReturnType<typeof d3.forceLink>[];
  public readonly graph: Observable<GraphData, this>;

  public readonly d3AlphaMin: Observable<number, this>;
  public readonly d3AlphaDecay: Observable<number, this>;
  public readonly d3AlphaTarget: Observable<number, this>;
  public readonly d3VelocityDecay: Observable<number, this>;
  public readonly warmupTicks: Observable<number, this>;
  public readonly cooldownTicks: Observable<number, this>;
  public readonly cooldownTimeMs: Observable<number, this>;
  public readonly onUpdate: Observable<() => void, this>;
  public readonly onFinishUpdate: Observable<() => void, this>;
  public readonly onEngineTick: Observable<() => void, this>;
  public readonly onEngineStop: Observable<() => void, this>;

  private engineRunning: boolean;
  private forceSimulation: d3.Simulation<d3.SimulationNodeDatum, undefined>;
  private cntTicks: number;
  private startTickTimeMs: number;

  constructor(initialGraph: InitialGraphData = { nodes: [], links: [] }
  ) {
    this.engineRunning = false;
    this.forceSimulation = d3.forceSimulation().stop();

    this.cntTicks = 0; // ticks passed from the start of countdown
    this.startTickTimeMs = Number(new Date()); // countdown start time
    this.engineRunning = false;

    this.linkForces = [];
    this.graph = new Observable(this, initialGraph as any as GraphData, [
      () => this.update(),
      // debounce(() => this.update(), 10),
    ]);

    this.d3AlphaMin = new Observable(this, 0, [])
    this.d3AlphaDecay = new Observable(this, 0.0228, [(value) => this.forceSimulation.alphaDecay(value)])
    this.d3AlphaTarget = new Observable(this, 0, [(value) => this.forceSimulation.alphaTarget(value)])
    this.d3VelocityDecay = new Observable(this, 0.4, [(value) => this.forceSimulation.velocityDecay(value)])

    this.warmupTicks = new Observable(this, 0, []) // how many times to tick the force engine at init before starting to render
    this.cooldownTicks = new Observable(this, Infinity, [])
    this.cooldownTimeMs = new Observable(this, 15000, [])

    this.onUpdate = new Observable(this, noop, [])
    this.onFinishUpdate = new Observable(this, noop, [])
    this.onEngineTick = new Observable(this, noop, [])
    this.onEngineStop = new Observable(this, noop, [])
  }

  public getForce(forceName: string) {
    return this.forceSimulation.force(forceName); // Force getter
  }

  public setForce<T extends Force<any, any>>(forceName: string, forceFn: T): T {
    this.forceSimulation.force(forceName, forceFn); // Force setter
    return forceFn;
  }

  public removeForce(forceName: string) {
    if(this.getForce(forceName)) {
      this.forceSimulation.force(forceName, null);
    }

    throw new Error(`Force '${forceName}' does not exist.`);
  }

  public createLinkForce(forceName: string): ReturnType<typeof d3.forceLink> {
    if(this.getForce(forceName)) {
      throw new Error(`Force '${forceName}' was already added.`);
    }

    const force = d3.forceLink().id(node => (node as GraphNode).id);
    this.forceSimulation.force(forceName, force);
    this.linkForces.push(force);
    return force;
  }

  public d3ReheatSimulation() {
    this.forceSimulation.alpha(1);
    this.resetCountdown();
  }
  public resetCountdown() { // reset cooldown state
    this.cntTicks = 0;
    this.startTickTimeMs = Number(new Date());
    this.engineRunning = true;
  }
  public isEngineRunning () {
    return this.engineRunning;
  }

  public tick() {
    if (!this.engineRunning) return;

    if (
      ++this.cntTicks > this.cooldownTicks.value ||
      Number(new Date()) - this.startTickTimeMs > this.cooldownTimeMs.value ||
      (this.d3AlphaMin.value > 0 && this.forceSimulation.alpha() < this.d3AlphaMin.value)
    ) {
      this.engineRunning = false; // Stop ticking graph
      this.onEngineStop.value();
    } else {
      this.forceSimulation.tick(); // Tick it
      this.onEngineTick.value();
    }
  }

  private update() {
    this.engineRunning = false; // Pause simulation
    this.onUpdate.value();

    // Feed data to force-directed layout and re-heat the simulation.
    this.forceSimulation.stop().alpha(1).nodes(this.graph.value.nodes);
    this.linkForces.forEach(force => {
      force.links(this.graph.value.links);
    });

    // Initial ticks before starting to render.
    // Repeat "warmupTicks" times or when simulation slows down enough.
    for (let i = 0; i < this.warmupTicks.value && !(this.d3AlphaMin.value > 0 && this.forceSimulation.alpha() < this.d3AlphaMin.value); i++) {
      this.forceSimulation.tick();
    }

    this.resetCountdown();
    this.onFinishUpdate.value();
  }

  public destructor() {
    this.graph.set({ nodes: [], links: [] });
  }
}
