import { immer } from "zustand/middleware/immer";

import ForceGraph from "../force-graph";
import { createGlobalStore, type GetState, type SetState } from "./store-utils";

import * as d3 from 'd3-force'

type GraphNode = {
  id: number;
  index: number;
  links: GraphLink[];
  neighbors: GraphNode[];

  // Autogenerated by d3-force (inplace)
  x: number;
  y: number;
  vx: number;
  vy: number;
  fx?: number;
  fy?: number;
}

type GraphLink = {
  id: number;
  source: GraphNode;
  target: GraphNode;
}

const argmax = <T>(arr: T[], func: (item: T) => number) => {
  if(!arr) throw Error("Expected a non-empty array.")
  
  let best = arr[0];
  let bestValue = func(best);

  for (const item of arr) {
    const value = func(item);
    if (value > bestValue) {
      best = item;
      bestValue = value;
    }
  }

  return best;
}

const storeFunction = () => {
  const container = document.getElementById("graph-container")
  if (!container) {
    throw new Error("Initialization failed. Element #graph-container does not exist.")
  }
  container.innerHTML = "";

  const N = 80;
  const gData = {
    nodes: [...Array(N).keys()].map(i => ({
      id: i,
      neighbors: [],
      links: [],
    })),
    links: [...Array(N).keys()]
      .filter(id => id)
      .map(id => ({
        source: id,
        target: Math.round(Math.random() * (id - 1)),
      }))
  };

  gData.links.forEach(link => {
    const a = gData.nodes[link.source];
    const b = gData.nodes[link.target];
    a.neighbors.push(b);
    b.neighbors.push(a);

    a.links.push(link);
    b.links.push(link);
  });

  const graphData = gData as unknown as {
    nodes: GraphNode[];
    links: GraphLink[];
  };

  const NODE_R = 8;
  const graphInstance = new ForceGraph(container);
  const containerStyle = getComputedStyle(container);

  const paddingX = parseFloat(containerStyle.paddingLeft) + parseFloat(containerStyle.paddingRight);
  const paddingY = parseFloat(containerStyle.paddingTop) + parseFloat(containerStyle.paddingBottom);
  const borderX = parseFloat(containerStyle.borderLeftWidth) + parseFloat(containerStyle.borderRightWidth);
  const borderY = parseFloat(containerStyle.borderTopWidth) + parseFloat(containerStyle.borderBottomWidth);
  const availableWidth = container.offsetWidth - paddingX - borderX;
  const availableHeight = container.offsetHeight - paddingY - borderY;

  let focusedNode = graphData.nodes[0]
  graphInstance
    .width(availableWidth)
    .height(availableHeight - 100)
    .graphData(gData)
    .nodeRelSize(NODE_R)
    .cooldownTicks(100)
    .d3Force('center', d3.forceCenter())
    .d3Force("charge", d3.forceManyBody())
    .onEngineStop(() => graphInstance.zoomToFit());

  return function store(
    set: SetState<typeof store>,
    get: GetState<typeof store>
  ) {
    graphInstance
      .nodeCanvasObjectMode(node => node === focusedNode ? 'before' : undefined)
      .nodeCanvasObject((node, ctx) => {
        if (node.x, node.y) {
          ctx.beginPath();
          ctx.arc(node.x ?? 0, node.y ?? 0, NODE_R * 1.4, 0, 2 * Math.PI, false);
          ctx.fillStyle = node === focusedNode ? 'red' : 'orange';
          ctx.fill();
        }
      });

    return {
      graphInstance: graphInstance,
      graphData: graphData,
      focusedNode: graphData.nodes[0],
      actions: {
        moveByDirection: (dirX: number, dirY: number) => {
          const node = focusedNode;
          const bestMatch = argmax(
            [node, ...node.neighbors],
            (neighbor) => (node.x - neighbor.x) * dirX + (node.y - neighbor.y) * dirY,
          );
          focusedNode = bestMatch;
        
          set(state => {
            state.focusedNode = bestMatch;
          })
        },

        moveFocusUp: () => get().actions.moveByDirection(0, -1),
        moveFocusDown: () => get().actions.moveByDirection(0, 1),
        moveFocusLeft: () => get().actions.moveByDirection(-1, 0),
        moveFocusRight: () => get().actions.moveByDirection(1, 0),
      },
    }
  }
}

export const {
  useStore: useGraphStore,
  useStoreShallow: useGraphStoreShallow,
  getStoreState: getGraphStoreState,
} = createGlobalStore(() => immer(storeFunction()))
