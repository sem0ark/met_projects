import { useCallback, useEffect, useRef, useState } from "react";
import ForceGraph from "../force-graph";

import * as d3 from "d3-force";

type GraphNode = {
  id: number;
  index: number;
  links: GraphLink[];
  neighbors: GraphNode[];

  // Autogenerated by d3-force (inplace)
  x: number;
  y: number;
  vx: number;
  vy: number;
  fx?: number;
  fy?: number;
};

type GraphLink = {
  id: number;
  source: GraphNode;
  target: GraphNode;
};

const findNeighborsUpToDepth = (
  startNode: GraphNode,
  maxDepth: number
): Set<GraphNode> => {
  const visited = new Set<GraphNode>();
  const queue: { node: GraphNode; depth: number }[] = [{ node: startNode, depth: 0 }];

  visited.add(startNode);

  while (queue.length > 0) {
    const { node, depth } = queue.shift()!; // Dequeue

    if (depth >= maxDepth) continue;

    for (const neighbor of node.neighbors) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push({ node: neighbor, depth: depth + 1 });
      }
    }
  }

  visited.delete(startNode);
  return visited;
};

export const Home = () => {
  const ref = useRef<HTMLDivElement>(null);
  const focusedNode = useRef<GraphNode>(undefined);
  const graphInstance = useRef<ForceGraph>(undefined);

  const [graphData] = useState(() => {
    const n = 10;
    const nodes = Array.from({length: n * n}, (_, i) => ({
      id: i,
      index: i,
      neighbors: [],
      links: [],
    }));

    const links = [];
    for (let y = 0; y < n; ++y) {
      for (let x = 0; x < n; ++x) {
        if (y > 0) links.push({source: (y - 1) * n + x, target: y * n + x});
        if (x > 0) links.push({source: y * n + (x - 1), target: y * n + x});
      }
    }
    const gData = {
      nodes: nodes,
      links: links,
    };

    gData.links.forEach((link) => {
      const a = gData.nodes[link.source];
      const b = gData.nodes[link.target];
      a.neighbors.push(b);
      b.neighbors.push(a);
      a.links.push(link);
      b.links.push(link);
    });

    return gData as unknown as {
      nodes: GraphNode[];
      links: GraphLink[];
    };
  });

  const getSize = useCallback(() => {
    if (!ref.current) return [0, 0];

    const style = getComputedStyle(ref.current);
    const paddingX =
      parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
    const paddingY =
      parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    const borderX =
      parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
    const borderY =
      parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
    const availableWidth = ref.current.offsetWidth - paddingX - borderX;
    const availableHeight = ref.current.offsetHeight - paddingY - borderY;

    return [availableWidth, availableHeight];
  }, []);

  // One-time instantiation and configuration
  useEffect(() => {
    console.log(ref.current);

    if (!ref.current || graphInstance.current) return; // Prevent re-instantiation

    const NODE_R = 8;
    const instance = new ForceGraph(ref.current);
    instance
      .nodeRelSize(NODE_R)
      .autoPauseRedraw(false)
      .cooldownTicks(100)
      .onEngineStop(() => instance.zoomToFit(100));

    graphInstance.current = instance;
  }, []);

  // apply dynamic configuration (data, size)
  useEffect(() => {
    if (!graphInstance.current) return;

    // Apply dynamic props to the existing instance
    const [availableWidth, availableHeight] = getSize();
    graphInstance.current
      .width(availableWidth)
      .height(availableHeight)
      .graphData(graphData);

    setTimeout(() => {
      graphInstance.current!.d3Force("charge", d3.forceManyBody().strength(-30));
      graphInstance.current!.d3Force("link", d3.forceLink(graphData.links).strength(1).distance(20));
    }, 10);

    // Set initial focused node after data is loaded
    if (graphData.nodes.length > 0) {
      focusedNode.current = graphData.nodes[0];
    }
  }, [graphData, getSize]); // Runs when data or size changes, updating the existing instance

  useEffect(() => {
    if (!graphInstance.current) return;
    const NODE_R = 8;

    // Apply render-specific configuration to the existing instance
    graphInstance.current
      .nodeCanvasObjectMode((node) =>
        node === focusedNode.current ? "before" : undefined
      )
      .nodeCanvasObject((node, ctx) => {
        if (node.x && node.y) {
          ctx.beginPath();
          ctx.arc(node.x ?? 0, node.y ?? 0, NODE_R * 1.4, 0, 2 * Math.PI, false);
          ctx.fillStyle = node === focusedNode.current ? "red" : "orange";
          ctx.fill();
        }
      });

    // We don't need a dependency array here for focusedNode.current because
    // the canvas functions are closures that close over the ref itself.
  }, []);

  const moveByDirection = useCallback((dirX: number, dirY: number) => {
    if (!focusedNode.current || !graphInstance.current) return;

    const currentNode = focusedNode.current;
    const potentialTargets = findNeighborsUpToDepth(currentNode, 4);

    if (potentialTargets.size === 0) return;

    let bestMatch: GraphNode | undefined = undefined;
    let minDistanceSq: number = Infinity;
    const directionTolerance = Math.cos(Math.PI / 4);

    for (const neighbor of potentialTargets) {
      if (neighbor.x !== 0 && !neighbor.x && !neighbor.y) continue;

      const dx = neighbor.x - currentNode.x;
      const dy = neighbor.y - currentNode.y;
      const distanceSq = dx * dx + dy * dy;

      if (distanceSq === 0) continue;

      const dotProduct = dx * dirX + dy * dirY;
      if (
        dotProduct > directionTolerance * Math.sqrt(distanceSq) &&
        distanceSq < minDistanceSq
      ) {
        minDistanceSq = distanceSq;
        bestMatch = neighbor;
      }
    }

    if (bestMatch) {
      focusedNode.current = bestMatch;
      return true;
    }

    return false;
  }, []);

  const onKeyDown = useCallback(
    (ev: KeyboardEvent) => {
      // Ensure that user is moving somewhere in the same direction.
      if (ev.key === "ArrowUp") return moveByDirection(0, -1);
      if (ev.key === "ArrowDown") return moveByDirection(0, 1);

      if (ev.key === "ArrowLeft" || ev.key === "ArrowRight") {
        const movedStraight = ev.key === "ArrowLeft" && moveByDirection(-1, 0) || ev.key === "ArrowRight" && moveByDirection(1, 0);

        if (movedStraight || !focusedNode.current || !ref.current) return;

        const currentNode = focusedNode.current;
        const [width, height] = getSize();

        // Assuming the D3 center is half the available width/height
        const centerX = width / 2;
        const centerY = height / 2;
        
        // Calculate the vector from the center to the current node
        const vecX = currentNode.x - centerX;
        const vecY = currentNode.y - centerY;

        // Calculate the magnitude for normalization (avoid Math.sqrt in loop, but need it here)
        const magnitude = Math.sqrt(vecX * vecX + vecY * vecY);

        if (magnitude === 0) return; // Avoid division by zero if exactly at center

        const unitVecX = vecX / magnitude;
        const unitVecY = vecY / magnitude;
        if (ev.key === "ArrowRight") {
          moveByDirection(unitVecY, -unitVecX);
        } else if (ev.key === "ArrowLeft") {
          moveByDirection(-unitVecY, unitVecX);
        }
      }
    },
    [moveByDirection, getSize]
  );

  useEffect(() => {
    addEventListener("keydown", onKeyDown);
    return () => removeEventListener("keydown", onKeyDown);
  }, [onKeyDown]);

  const onResize = useCallback(() => {
    if (!graphInstance.current) return;
    const [availableWidth, availableHeight] = getSize();
    graphInstance.current.width(availableWidth).height(availableHeight);
  }, [getSize]);

  useEffect(() => {
    addEventListener("resize", onResize);
    return () => removeEventListener("resize", onResize);
  }, [onResize]);

  return (
    <div
      ref={ref}
      autoFocus
      className="w-screen -z-10 h-screen m-0 p-0 border-2 absolute top-0 left-0"
    ></div>
  );
};
