/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * Helper function signature for deriving a key from an item.
 */
type KeyAccessorFn<T> = (item: T) => any;

/**
 * Maps the list of Key Accessors provided to the final, flat, strongly typed result.
 * It infers the resulting tuple of KeyTypes based on the input accessors.
 */
type FlatResultFromAccessors<T, Accessors extends KeyAccessorFn<T>[]> = {
  // Infer the types of the keys generated by the accessors as a tuple (K)
  keys: { [I in keyof Accessors]: ReturnType<Accessors[I]> }; 
  values: T[];
}[];

/**
 * Executes the indexing process and returns the result as a flat list of 
 * {keys: [], values: []} objects with strongly typed keys inferred from accessors.
 * 
 * This implementation avoids deep recursive types by operating on runtime data structures
 * and leveraging type inference over the input accessors array.
 * 
 * @param list The input array of items to index.
 * @param accessors An array of functions to derive keys sequentially.
 */
export function toFlat<T, Accessors extends KeyAccessorFn<T>[]>(
  list: T[],
  accessors: [...Accessors]
): FlatResultFromAccessors<T, Accessors> {
  // Use an internal generic intermediate structure (Record<string, unknown>)
  // instead of relying on recursive TypeScript generics for the intermediate structure.
  const result: FlatResultFromAccessors<T, Accessors> = [];

  // Helper to perform the initial nested aggregation using Maps
  const buildNestedMap = () => {
    // The top-level result is a Map
    const rootMap = new Map<string | number, any>(); 

    for (const item of list) {
      let currentLevel: Map<any, any> = rootMap;
      
      accessors.forEach((keyAccessor, idx) => {
        const key = keyAccessor(item);

        if (idx + 1 < accessors.length) {
          // If a Map for this key doesn't exist, create it
          if (!currentLevel.has(key)) {
            currentLevel.set(key, new Map<any, any>());
          }
          currentLevel = currentLevel.get(key);
        } else {
          // Leaf node: If an array for this key doesn't exist, create it
          if (!currentLevel.has(key)) {
            currentLevel.set(key, []);
          }
          currentLevel.get(key).push(item);
        }
      });
    }
    return rootMap;
  };

  const indexedMapResult = buildNestedMap();

  // Helper function to flatten the *runtime* Map structure into the typed result array
  // Uses recursion via iteration over Map entries
  function flatten(node: Map<any, any> | T[], accKeys: (string | number)[] = []) {
    if (Array.isArray(node)) {
      if (node.length > 0) {
          // Push the final runtime data into the typed result array with a cast
          result.push({
              keys: accKeys,
              values: node,
          } as any); 
      }
    } else if (node instanceof Map) {
      for (const [key, val] of node.entries()) {
        flatten(val, [...accKeys, key]);
      }
    }
  }

  // Run the flatten operation
  flatten(indexedMapResult);

  // Handle the edge case of an empty accessor list (no keys provided)
  if (result.length === 0 && accessors.length === 0 && list.length > 0) {
      return [{ keys: [], values: list }] as any;
  }

  return result;
}
