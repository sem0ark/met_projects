import { useCallback, useEffect, useRef } from "react";
import ForceGraph from "force-graph";

import * as d3 from "d3-force";

type GraphNode = {
  id: number;
  links: GraphLink[];
  neighbors: GraphNode[];

  // Autogenerated by d3-force (inplace)
  x: number;
  y: number;
  vx: number;
  vy: number;
  fx?: number;
  fy?: number;
};

type GraphLink = {
  id: number;
  source: GraphNode;
  target: GraphNode;
};

type GraphData = {
  nodes: GraphNode[];
  links: GraphLink[];
};

type InputGraphData = {
  nodes: {
    id: number;
    x?: number;
    y?: number;
    vx?: number;
    vy?: number;
    fx?: number;
    fy?: number;
  }[];

  links: {source: number; target: number}[];
}

const findNeighborsUpToDepth = (
  startNode: GraphNode,
  maxDepth: number,
): Set<GraphNode> => {
  const visited = new Set<GraphNode>();
  const queue: { node: GraphNode; depth: number }[] = [
    { node: startNode, depth: 0 },
  ];

  visited.add(startNode);

  while (queue.length > 0) {
    const { node, depth } = queue.shift()!; // Dequeue

    if (depth >= maxDepth) continue;

    for (const neighbor of node.neighbors) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push({ node: neighbor, depth: depth + 1 });
      }
    }
  }

  visited.delete(startNode);
  return visited;
};


type GraphNodeSelectorConfig = {
  name: string
  radius: number
  color: string // css color
}
// type GraphControllerOptions = {}

class GraphController {
  private instance: ForceGraph;

  private selectors: Map<string, { node: GraphNode } & GraphNodeSelectorConfig> = new Map();
  private nodeToConfigs: Map<GraphNode, GraphNodeSelectorConfig[]> = new Map()

  private graphData: GraphData;

  constructor(instance: ForceGraph, initialData: InputGraphData) {
    this.instance = instance;
    this.instance
      .nodeRelSize(5)
      .autoPauseRedraw(false)
      .cooldownTicks(100)
      .graphData(initialData);

    this.graphData = this.instance.graphData() as GraphData;
    this.updateLocalNeighborhoods(this.graphData.links);

    this.initGraph();
  }

  private initGraph() {
    this.instance
      .nodeCanvasObjectMode((node) => {
        return this.nodeToConfigs.has(node as GraphNode) ? "before" : undefined
      })
      .nodeCanvasObject((node, ctx) => nodePaint(node, this.instance.nodeColor(), ctx))
      .nodePointerAreaPaint(nodePaint)
      .nodeCanvasObject((node, ctx) => {
        if (node.x && node.y) {
          const configs = this.nodeToConfigs.get(node as GraphNode);
          if (!configs) return;

          for (const config of configs) {
            ctx.beginPath();
            ctx.arc(node.x, node.y, config.radius ?? 5, 0, 2 * Math.PI, false);
            ctx.strokeStyle = config.color ?? "blue"; 
            ctx.stroke();
          }
        }
      });

    // Bind forces
    this.instance
      .d3Force("charge", d3.forceManyBody().strength(-30))
      .d3Force("link", d3.forceLink(this.graphData.links).strength(1).distance(20));
  }

  public setDimensions(width: number, height: number) {
    if (!this.instance) return;
    this.instance.width(width).height(height);
  }

  public createSelector(config: GraphNodeSelectorConfig): GraphNode {
    if (this.selectors.get(config.name)) throw new Error(`Selector configuration with name '${config.name}' already exists.`);

    const node = this.graphData.nodes.at(-1)!;
    this.selectors.set(config.name, {node, ...config})

    this.nodeToConfigs.set(node, this.nodeToConfigs.get(node) ?? []);
    this.nodeToConfigs.get(node)?.push(config);
    return node;
  }

  public setSelector(node: GraphNode, config: GraphNodeSelectorConfig) {
    const existingNode = this.selectors.get(config.name)?.node;
    this.selectors.set(config.name, { node, ...config })

    if (existingNode) {
      this.nodeToConfigs.set(existingNode, this.nodeToConfigs.get(existingNode)?.filter(v => v !== config) ?? [])
    }
    this.nodeToConfigs.set(node, this.nodeToConfigs.get(node) ?? []);
    this.nodeToConfigs.get(node)?.push(config);
  }

  public getClosestByDirection(currentNode: GraphNode, dirX: number, dirY: number): GraphNode {
    if (!this.instance) return currentNode;
    const neighbors = findNeighborsUpToDepth(currentNode, 4);
    const directionTolerance = Math.cos(Math.PI / 4);

    let bestMatch: GraphNode = currentNode;
    let minDistanceSq: number = Infinity;

    for (const neighbor of neighbors) {
      if (neighbor.x !== 0 && !neighbor.x || !neighbor.y) continue;
      const dx = neighbor.x - currentNode.x;
      const dy = neighbor.y - currentNode.y;
      const distanceSq = dx * dx + dy * dy;

      if (distanceSq === 0) continue;
      const dotProduct = dx * dirX + dy * dirY;

      if (dotProduct > directionTolerance * Math.sqrt(distanceSq) && distanceSq < minDistanceSq) {
        minDistanceSq = distanceSq;
        bestMatch = neighbor;
      }
    }

    return bestMatch;
  }

  public updateLocalNeighborhoods(links: GraphLink[]) {
    for(const link of links) {
      link.source.neighbors = link.source.neighbors ?? [];
      link.target.neighbors = link.target.neighbors ?? [];
      link.source.links = link.source.links ?? [];
      link.target.links = link.target.links ?? [];

      link.source.neighbors.push(link.target);
      link.target.neighbors.push(link.source);
      link.source.links.push(link);
      link.target.links.push(link);
    }
  }

  public addLink(linkData: Partial<GraphLink>, nodeFrom: GraphNode, nodeTo: GraphNode): GraphLink {
    const newLink = {source: nodeFrom.id, target: nodeTo.id, ...linkData}
    this.instance.graphData({
      nodes: this.graphData.nodes,
      links: [...this.graphData.links, newLink],
    });

    this.graphData = this.instance.graphData() as GraphData;
    const updatedLink = newLink as unknown as GraphLink; // modified inplace by d3-force

    this.updateLocalNeighborhoods([updatedLink]);
    return updatedLink;
  }

  public addNode(nodeData: Partial<GraphNode>, neighbors: GraphNode[]): GraphNode {
    const newId = this.graphData.nodes.length;
    const newNode = {...nodeData, id: newId};
    const newLinks = [];

    for(const neighbor of neighbors) {
      newLinks.push({
        source: newNode.id,
        target: neighbor.id,
      });
    }

    this.instance.graphData({
      nodes: [...this.graphData.nodes, newNode],
      links: [...this.graphData.links, ...newLinks],
    });
    this.graphData = this.instance.graphData() as GraphData;
    const updatedLinks = newLinks as unknown as GraphLink[]; // modified inplace by d3-force

    this.updateLocalNeighborhoods(updatedLinks);
    return newNode as GraphNode;
  }
}

class SchemaController {
  public readonly schemaView: GraphController;

  private startStitchFocus: GraphNode;
  private startStitchConfig = {
    name: "start-stitch",
    radius: 5 * 1.4,
    color: "green",
  };
  private targetStitchFocus: GraphNode;
  private targetStitchConfig = {
    name: "target-stitch",
    radius: 5 * 1.2,
    color: "red",
  };

  constructor(schemaView: GraphController) {
    this.schemaView = schemaView;
    this.targetStitchFocus = this.schemaView.createSelector(this.startStitchConfig)
    this.startStitchFocus = this.schemaView.createSelector(this.targetStitchConfig)
  }

  public getStartStitch() {
    return this.startStitchFocus;
  }
  public setStartStitch(node: GraphNode) {
    this.schemaView.setSelector(node, this.startStitchConfig)
    this.startStitchFocus = node;
  }
  public getTargetStitch() {
    return this.targetStitchFocus;
  }
  public setTargetStitch(node: GraphNode) {
    this.schemaView.setSelector(node, this.targetStitchConfig)
    this.targetStitchFocus = node;
  }

  public addChainStitch() {
    const newNode = this.schemaView.addNode({
      x: this.startStitchFocus.x + 10,
      y: this.startStitchFocus.y - 5 + 10 * Math.random(),
    }, [this.startStitchFocus]);
    this.setStartStitch(newNode);
  }

  public addLinkStitch() {
    if (this.startStitchFocus === this.targetStitchFocus || this.startStitchFocus.links.some(l => l.source === this.targetStitchFocus || l.target === this.targetStitchFocus)) return;
    this.schemaView.addLink({}, this.startStitchFocus, this.targetStitchFocus);
  }
}

export const SchemaEditor = ({className, inputData}: {
  className?: string
  inputData: InputGraphData
}) => {
  const ref = useRef<HTMLDivElement>(null);
  const controllerRef = useRef<SchemaController>(undefined);

  const getSize = useCallback(() => {
    if (!ref.current) return [0, 0];

    const style = getComputedStyle(ref.current);
    const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
    const paddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    const borderX = parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
    const borderY = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
    const availableWidth = ref.current.offsetWidth - paddingX - borderX;
    const availableHeight = ref.current.offsetHeight - paddingY - borderY;

    return [availableWidth, availableHeight];
  }, []);

  // One-time instantiation and configuration
  useEffect(() => {
    if (!ref.current || controllerRef.current) return; // Prevent re-instantiation

    const instance = new SchemaController(new GraphController(new ForceGraph(ref.current), inputData));
    controllerRef.current = instance;

    // TODO: Ensure proper destruction
    // return () => {
    //   container.innerHTML = ""
    // }
  }, [inputData]);

  // Init view configuration
  useEffect(() => {
    if (!controllerRef.current) return;
    const [availableWidth, availableHeight] = getSize();
    controllerRef.current.schemaView.setDimensions(availableWidth, availableHeight);
  }, [getSize]);

  const onKeyDown = useCallback(
    (ev: KeyboardEvent) => {
      if (!controllerRef.current) return;
      const controller = controllerRef.current;

      const isChangingTargetStitch = !ev.shiftKey;
      const currentNode = isChangingTargetStitch ? controller.getTargetStitch() : controller.getStartStitch();
      const moveByDirection = (dirX: number, dirY: number) => {
        const target = controller.schemaView.getClosestByDirection(currentNode, dirX, dirY);
        console.log(dirX, dirY, target === currentNode);

        if (target === currentNode) return false;
        if (isChangingTargetStitch) {
          controller.setTargetStitch(target);
        } else {
          controller.setStartStitch(target);
        }
        return true;
      }

      // Ensure that user is moving somewhere in the same direction.
      if (ev.key === "ArrowUp") return moveByDirection(0, -1);
      if (ev.key === "ArrowDown") return moveByDirection(0, 1);

      if (ev.key === "ArrowLeft" || ev.key === "ArrowRight") {
        const movedStraight =
          (ev.key === "ArrowLeft" && moveByDirection(-1, 0)) ||
          (ev.key === "ArrowRight" && moveByDirection(1, 0));

        if (movedStraight) return true;

        const vecX = currentNode.x;
        const vecY = currentNode.y;

        const magnitude = Math.sqrt(vecX * vecX + vecY * vecY);
        if (magnitude === 0) return; // Avoid division by zero if exactly at center

        const unitVecX = vecX / magnitude;
        const unitVecY = vecY / magnitude;
        if (ev.key === "ArrowLeft") {
          return moveByDirection(unitVecY, -unitVecX);
        } else if (ev.key === "ArrowRight") {
          return moveByDirection(-unitVecY, unitVecX);
        }
      }

      if (ev.key === "c") {
        controller.addChainStitch()
      }

      if (ev.key === "l") {
        controller.addLinkStitch()
      }
    },
    [],
  );

  useEffect(() => {
    addEventListener("keydown", onKeyDown);
    return () => removeEventListener("keydown", onKeyDown);
  }, [onKeyDown]);

  const onResize = useCallback(() => {
    if (!controllerRef.current) return;
    const [availableWidth, availableHeight] = getSize();
    controllerRef.current.schemaView.setDimensions(availableWidth, availableHeight);
  }, [getSize]);

  useEffect(() => {
    addEventListener("resize", onResize);
    return () => removeEventListener("resize", onResize);
  }, [onResize]);

  return (
    <div ref={ref} className={className}></div>
  );
};
