/* eslint-disable @typescript-eslint/no-explicit-any */
import * as d3 from "d3-force";
import { type Force } from "d3-force";

import { asKapsuleConfig, type ExtractKapsuleStateType } from "./kapsule";

const noop = () => {}


export type GraphNode = {
  id: number;
  links: GraphLink[];
  neighbors: GraphNode[];

  // Autogenerated by d3-force (inplace)
  x: number;
  y: number;
  vx: number;
  vy: number;
  fx?: number;
  fy?: number;
};

export type GraphLink = {
  id: number;
  source: GraphNode;
  target: GraphNode;
};

export type GraphData = {
  nodes: GraphNode[];
  links: GraphLink[];
};

export const d3ForceConfig = asKapsuleConfig({
  props: {
    graphData: {
      default: { nodes: [], links: [] } as GraphData,
      onChange(_, state) {
        state.engineRunning = false; // Pause simulation
      },
    },

    tickSteps: {
      // list of callbacks receiving the current state to make an action on a tick
      default: [] as ((state: any /* StateType */) => void)[]
    },

    d3AlphaMin: { default: 0, triggerUpdate: false },
    d3AlphaDecay: {
      default: 0.0228,
      triggerUpdate: false,
      onChange(alphaDecay, state) {
        state.forceSimulation.alphaDecay(alphaDecay);
      },
    },
    d3AlphaTarget: {
      default: 0,
      triggerUpdate: false,
      onChange(alphaTarget, state) {
        state.forceSimulation.alphaTarget(alphaTarget);
      },
    },
    d3VelocityDecay: {
      default: 0.4,
      triggerUpdate: false,
      onChange(velocityDecay, state) {
        state.forceSimulation.velocityDecay(velocityDecay);
      },
    },

    warmupTicks: { default: 0, triggerUpdate: false }, // how many times to tick the force engine at init before starting to render
    cooldownTicks: { default: Infinity, triggerUpdate: false },
    cooldownTimeMs: { default: 15000, triggerUpdate: false },

    onUpdate: { default: noop, triggerUpdate: false },
    onFinishUpdate: { default: noop, triggerUpdate: false },
    onEngineTick: { default: noop, triggerUpdate: false },
    onEngineStop: { default: noop, triggerUpdate: false },
  },
    
  methods: {
    addD3Force: (state, forceName: string, forceFn?: Force<any, any>) => {
      if (forceFn === undefined) {
        return state.forceSimulation.force(forceName); // Force getter
      }
      state.forceSimulation.force(forceName, forceFn); // Force setter
    },
    d3ReheatSimulation(state) {
      state.forceSimulation.alpha(1);
      d3ForceConfig.methods.resetCountdown(state);
    },
    resetCountdown(state) { // reset cooldown state
      state.cntTicks = 0;
      state.startTickTimeMs = Number(new Date());
      state.engineRunning = true;
    },
    isEngineRunning: (state) => !!state.engineRunning,

    tickFrame(state) {
      state.tickSteps?.forEach(step => step(state))
    },
  },

  stateInit: () => ({
    forceSimulation: d3.forceSimulation().stop(),
      // .force("link", d3ForceLink())
      // .force("charge", d3ForceManyBody())
      // .force("center", d3ForceCenter())
      // .force("dagRadial", null)

    cntTicks: 0, // ticks passed from the start of countdown
    startTickTimeMs: Number(new Date()), // countdown start time
    engineRunning: false,
  }),

  update(state) {
    state.engineRunning = false; // Pause simulation
    state.onUpdate();

    // Feed data to force-directed layout
    state.forceSimulation
      .stop()
      .alpha(1) // re-heat the simulation
      .nodes(state.graphData.nodes);

    // add links (if link force is still active)
    const linkForce = state.forceSimulation.force("link")! as ReturnType<typeof d3.forceLink>;
    if (linkForce) {
      linkForce.id(node => (node as GraphNode).id).links(state.graphData.links);
    }

    // Initial ticks before starting to render.
    // Repeat "state.warmupTicks" times or when simulation slows down enough.
    for (let i = 0; i < state.warmupTicks && !(state.d3AlphaMin > 0 && state.forceSimulation.alpha() < state.d3AlphaMin); i++) {
      state.forceSimulation.tick();
    }

    d3ForceConfig.methods.resetCountdown(state);
    state.onFinishUpdate();
  },
})

export const d3CanvasGraphConfig = asKapsuleConfig({
  ...d3ForceConfig,

  stateInit: ({ canvasContext }: {
    canvasContext: CanvasRenderingContext2D
  }) => ({
    ...d3ForceConfig.stateInit!({}),
    canvasContext: canvasContext,
  }),
})

// Rendering logic

type D3ForceGraphState = ExtractKapsuleStateType<typeof d3ForceConfig>;
const untypedCallbackWrapper = <T, R>(cb: (data: T) => R) => cb as ((data: any) => R)

export const layoutTick = untypedCallbackWrapper<D3ForceGraphState, void>((state) => {
  if (!state.engineRunning) return;

  if (
    ++state.cntTicks > state.cooldownTicks ||
    Number(new Date()) - state.startTickTimeMs > state.cooldownTimeMs ||
    (state.d3AlphaMin > 0 && state.forceSimulation.alpha() < state.d3AlphaMin)
  ) {
    state.engineRunning = false; // Stop ticking graph
    state.onEngineStop();
  } else {
    state.forceSimulation.tick(); // Tick it
    state.onEngineTick();
  }
})
